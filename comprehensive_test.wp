# Test App

GET /hello/:world
  |> jq: `{ world: .params.world }`
  |> handlebars: `<p>hello, {{world}}</p>`

describe "hello, world"
  it "calls the route"
    when calling GET /hello/world
    then status is 200
    and output equals `<p>hello, world</p>`

GET /lua/:id/example
  |> lua: `
    local id = request.params.id
    local name = request.query.name
    return {
      message = "Hello from Lua!",
      id = id,
      name = name
    }
  `
describe "lua"
  it "calls the route"
    when calling GET /lua/123/example?name=example
    then status is 200
    and output equals `{
      "message": "Hello from Lua!",
      "id": 123,
      "name": "example"
    }`

## Config
config pg {
  host: $WP_PG_HOST || "localhost"
  port: $WP_PG_PORT || "5432"
  database: $WP_PG_DATABASE || "express-test"
  user: $WP_PG_USER || "postgres"
  password: $WP_PG_PASSWORD || "postgres"
  ssl: false
  initialPoolSize: 10
  maxPoolSize: 20
}

config auth {
  sessionTtl: 604800
  cookieName: "wp_session"
  cookieSecure: false
  cookieHttpOnly: true
  cookieSameSite: "Lax"
  cookiePath: "/"
}

## Tests

GET /test-lua-env
  |> lua: `
    local env = getEnv("WP_PG_USER")
    return {
      env = env
    }
  `

pipeline getTeams =
  |> jq: `{ sqlParams: [.params.id] }`
  |> pg: `SELECT * FROM teams WHERE id = $1`

GET /hello
  |> jq: `{ hello: "world" }`

GET /page/:id
  |> pipeline: getTeams
  |> jq: `{ team: .data.rows[0] }`

pg teamsQuery = `SELECT * FROM teams`

GET /teams
  |> jq: `{ sqlParams: [] }`
  |> pg: teamsQuery

# Testing standalone variables
describe "teamsQuery variable"
  with mock pg.teamsQuery returning `{
    "rows": [
      { "id": "1", "name": "Platform" },
      { "id": "2", "name": "Growth" },
      { "id": "3", "name": "Security" }
    ]
  }`

  it "returns all teams"
    when executing variable pg teamsQuery
    with input `{ "sqlParams": [] }`
    then output equals `{
      "rows": [
        { "id": "1", "name": "Platform" },
        { "id": "2", "name": "Growth" },
        { "id": "3", "name": "Security" }
      ]
    }`

# Testing a pipeline directly
describe "getTeams pipeline"
  with mock pg returning `{
    "rows": [{ "id": "2", "name": "Growth", "created_at": "2024-01-20" }]
  }`

  it "transforms params and queries database"
    when executing pipeline getTeams
    with input `{ "params": { "id": "2" } }`
    then output equals `{
      "rows": [{ "id": "2", "name": "Growth", "created_at": "2024-01-20" }]
    }`

  it "handles string id parameter"
    when executing pipeline getTeams
    with input `{ "params": { "id": 42 } }`
    and mock pg returning `{ "rows": [{ "id": 42, "name": "Marketing" }] }`
    then output equals `{
      "rows": [{ "id": 42, "name": "Marketing" }]
    }`

  it "supports jq equals on output subpath"
    when executing pipeline getTeams
    with input `{ "params": { "id": 42 } }`
    and mock pg returning `{ "rows": [{ "id": 42, "name": "Marketing" }] }`
    then output `.rows[0].id` equals 42

describe "test calling route"
  it "calls the route"
    when calling GET /hello
    then status is 200
    and output equals `{
      "hello": "world"
    }`

describe "jq assertions"
  it "supports output contains for partial JSON"
    when calling GET /hello
    then output contains `{ "hello": "world" }`

  it "supports output matches for HTML"
    when calling GET /hello/world
    then output matches `^<p>hello, .*</p>$`

  it "supports status ranges"
    when calling GET /hello
    then status in 200..299

  it "supports jq filter with map"
    when executing pipeline getTeams
    with input `{ "params": { "id": 2 } }`
    and mock pg returning `{ "rows": [{ "id": 2, "name": "Growth" }, { "id": 3, "name": "Security" }] }`
    then output `.rows | map(.id)` equals `[2, 3]`

GET /test
  |> jq: `.`

GET /test2
  |> lua: `return request`

GET /lua-cpu
  |> lua: `
    -- CPU-heavy Lua route for benchmarking (small response)
    local total = 0
    local sumsq = 0
    for i = 1, 100000 do
      total = total + i
      sumsq = sumsq + (i * i)
    end

    local function is_prime(n)
      if n < 2 then return false end
      local limit = math.floor(math.sqrt(n))
      for d = 2, limit do
        if (n % d) == 0 then return false end
      end
      return true
    end

    local primes = 0
    for i = 2, 2000 do
      if is_prime(i) then primes = primes + 1 end
    end

    return {
      note = "CPU-bound Lua result (sum/sumsq/primes)",
      sum = total,
      sumsq = sumsq,
      primesUpTo2000 = primes
    }
  `

GET /lua-pipeline-benchmark
  |> lua: `
    -- Stage 1: Initialize with user data and array
    return {
      user = {
        id = 12345,
        name = "Test User",
        email = "test@example.com",
        roles = {"admin", "developer", "moderator"}
      },
      data = {},
      items = {},
      stage = 1,
      timestamp = os.time()
    }
  `
  |> lua: `
    -- Stage 2: Generate array of 100 items with metadata
    local items = {}
    for i = 1, 100 do
      items[i] = {
        id = i,
        value = i * 10,
        squared = i * i,
        label = "Item_" .. tostring(i)
      }
    end

    return {
      user = request.user,
      data = request.data,
      items = items,
      itemCount = 100,
      stage = 2,
      timestamp = request.timestamp
    }
  `
  |> lua: `
    -- Stage 3: Process items and calculate statistics
    local total = 0
    local squared_total = 0
    local processed = {}

    for i, item in ipairs(request.items) do
      total = total + item.value
      squared_total = squared_total + item.squared
      if item.value % 20 == 0 then
        processed[#processed + 1] = {
          id = item.id,
          value = item.value,
          category = "special"
        }
      end
    end

    return {
      user = request.user,
      items = request.items,
      itemCount = request.itemCount,
      data = {
        sum = total,
        squaredSum = squared_total,
        average = total / request.itemCount,
        specialItems = processed
      },
      stage = 3,
      timestamp = request.timestamp
    }
  `
  |> lua: `
    -- Stage 4: Add computed fields and enrich user data
    local userScore = 0
    for i, role in ipairs(request.user.roles) do
      userScore = userScore + string.len(role) * 10
    end

    local enrichedUser = {
      id = request.user.id,
      name = request.user.name,
      email = request.user.email,
      roles = request.user.roles,
      roleCount = #request.user.roles,
      computed = {
        score = userScore,
        level = math.floor(userScore / 50),
        badge = userScore > 150 and "gold" or "silver"
      }
    }

    return {
      user = enrichedUser,
      items = request.items,
      itemCount = request.itemCount,
      data = request.data,
      stage = 4,
      timestamp = request.timestamp
    }
  `
  |> lua: `
    -- Stage 5: Final aggregation and response formatting
    local processingTime = os.time() - request.timestamp

    return {
      summary = {
        user = request.user.name,
        userId = request.user.id,
        userLevel = request.user.computed.level,
        userBadge = request.user.computed.badge,
        totalItems = request.itemCount,
        specialItemsFound = #request.data.specialItems,
        dataProcessed = {
          sum = request.data.sum,
          average = request.data.average,
          squaredSum = request.data.squaredSum
        }
      },
      performance = {
        stages = 5,
        processingTimeSeconds = processingTime,
        itemsProcessed = request.itemCount,
        note = "5 Lua stages with data passing - tests zero-copy architecture"
      },
      benchmark = {
        route = "/lua-pipeline-benchmark",
        purpose = "A/B test Phase 1 performance improvements",
        expectation = "Reduced memory allocations and faster execution"
      }
    }
  `

GET /test3
  |> jq: `{message: "Hello World", status: "success"}`
  |> result
    ok(200):
      |> jq: `{
        success: true,
        data: .message,
        timestamp: now
      }`
    default(500):
      |> jq: `{
        error: "Something went wrong",
        timestamp: now
      }`

GET /test4
  |> jq: `{
    errors: [
      {
        type: "validationError",
        field: "email",
        message: "Email is required",
        code: "FIELD_REQUIRED"
      }
    ]
  }`
  |> result
    ok(200):
      |> jq: `{success: true}`
    validationError(400):
      |> jq: `{
        error: "Validation failed",
        field: .errors[0].field,
        message: .errors[0].message,
        code: .errors[0].code
      }`
    default(500):
      |> jq: `{error: "Internal server error"}`

GET /test5
  |> jq: `{
    errors: [
      {
        type: "authRequired",
        header: "Authorization",
        expected: "Bearer <token>",
        provided: null
      }
    ]
  }`
  |> result
    ok(200):
      |> jq: `{success: true, data: .result}`
    authRequired(401):
      |> jq: `{
        error: "Authentication required",
        header: .errors[0].header,
        expected: .errors[0].expected,
        provided: .errors[0].provided
      }`
    default(500):
      |> jq: `{error: "Internal server error"}`

GET /test6
  |> jq: `{
    errors: [
      {
        type: "unknownError",
        message: "This is a custom error type not handled explicitly"
      }
    ]
  }`
  |> result
    ok(200):
      |> jq: `{success: true}`
    validationError(400):
      |> jq: `{error: "Validation error"}`
    default(500):
      |> jq: `{
        error: "Unhandled error occurred",
        type: .errors[0].type,
        message: .errors[0].message
      }`

GET /test7
  |> lua: `
    -- Test executeSql function in Lua with parameterized queries
    local limit = 5
    local result, err = executeSql("SELECT * FROM teams LIMIT $1", {limit})

    if err then
      return {
        error = "Database error: " .. err,
        sql = "SELECT * FROM teams LIMIT $1"
      }
    end

    return {
      message = "Lua executeSql test successful (parameterized)",
      sql = "SELECT * FROM teams LIMIT $1",
      data = result,
      luaVersion = _VERSION
    }
  `


GET /test-sql-error
  |> jq: `{ sqlParams: [] }`
  |> pg: `SELECT * FROM nonexistent_table`
  |> result
    ok(200):
      |> jq: `{success: true, data: .data}`
    sqlError(500):
      |> jq: `{
        error: "Database error",
        sqlstate: .errors[0].sqlstate,
        message: .errors[0].message,
        query: .errors[0].query
      }`
    default(500):
      |> jq: `{error: "Internal server error"}`

POST /users
  |> jq: `{
    method: .method,
    name: .body.name,
    email: .body.email,
    action: "create"
  }`

PUT /users/:id
  |> jq: `{
    method: .method,
    id: (.params.id | tonumber),
    name: .body.name,
    email: .body.email,
    action: "update"
  }`

POST /test-body
  |> jq: `{
    method: .method,
    body: .body,
    hasBody: (.body != null)
  }`

PUT /test-body
  |> jq: `{
    method: .method,
    body: .body,
    hasBody: (.body != null)
  }`

GET /hello-handlebars
  |> jq: `{ name: "World", message: "Hello from handlebars!" }`
  |> handlebars: `
    <html>
      <head>
        <title>{{message}}</title>
      </head>
      <body>
        <h1>{{message}}</h1>
        <p>Hello, {{name}}!</p>
      </body>
    </html>
  `

GET /handlebars-error-test
  |> jq: `{ invalid: "data" }`
  |> handlebars: `{{syntax_error`

handlebars cardPartial = `
  <div class="card">
    <h3>{{title}}</h3>
    <p>{{description}}</p>
  </div>
`

handlebars headerPartial = `
  <header>
    <h1>{{siteName}}</h1>
    <nav>{{>navPartial}}</nav>
  </header>
`

handlebars navPartial = `
  <ul>
    <li><a href="/">Home</a></li>
    <li><a href="/about">About</a></li>
  </ul>
`

GET /test-partials
  |> jq: `{ 
    title: "Welcome", 
    description: "This is a test card",
    siteName: "My Website"
  }`
  |> handlebars: `
    <html>
      <head>
        <title>{{siteName}}</title>
      </head>
      <body>
        {{>headerPartial}}
        <main>
          {{>cardPartial}}
        </main>
      </body>
    </html>
  `

GET /test-missing-partial
  |> jq: `{ title: "Test" }`
  |> handlebars: `
    <html>
      <body>
        {{>nonexistentPartial}}
      </body>
    </html>
  `

GET /test-sql-error-handlebars
  |> jq: `{ sqlParams: [] }`
  |> pg: `SELECT * FROM nonexistent_table`
  |> result
    ok(200):
      |> jq: `{success: true, data: .data}`
    sqlError(500):
      |> jq: `{
        error: "Database error",
        sqlstate: .errors[0].sqlstate,
        message: .errors[0].message,
        query: .errors[0].query
      }`
      |> handlebars: `{{error}}`
    default(500):
      |> jq: `{error: "Internal server error"}`
      |> handlebars: `{{error}}`

GET /cookies
  |> jq: `{
    message: "Cookie test response",
    cookies: .cookies,
    setCookies: [
      "sessionId=abc123; HttpOnly; Secure; Max-Age=3600",
      "userId=john; Max-Age=86400",
      "theme=dark; Path=/"
    ]
  }`

GET /auth/status
  |> auth: "optional"
  |> jq: `{
    authenticated: (.user != null),
    user: .user,
    message: if .user then "User is authenticated" else "User is not authenticated" end
  }`

GET /debug/users
  |> jq: `{ sqlParams: [] }`
  |> pg: `SELECT id, login, email, type, status, created_at FROM users LIMIT 5`
  |> jq: `{
    message: "Users in database",
    users: .data.rows,
    count: (.data.rows | length)
  }`

GET /debug/test-user
  |> jq: `{ sqlParams: ["admin"] }`
  |> pg: `SELECT id, login, password_hash, email, type, status FROM users WHERE login = $1 AND status = 'active'`
  |> jq: `{
    message: "Test user lookup for 'admin'",
    found: (.data.rows | length > 0),
    user: if (.data.rows | length > 0) then .data.rows[0] else null end
  }`

GET /debug/users-schema
  |> jq: `{ sqlParams: [] }`
  |> pg: `SELECT column_name, data_type, is_nullable, column_default FROM information_schema.columns WHERE table_name = 'users' ORDER BY ordinal_position`
  |> jq: `{
    message: "Users table schema",
    columns: .data.rows
  }`

POST /debug/test-hash
  |> auth: "register"
  |> jq: `{
    message: "Test hash generation (this will fail but show us what's happening)",
    body: .body,
    errors: .errors
  }`

config cache {
  enabled: true
  defaultTtl: 60
  maxCacheSize: 10485760
}

GET /cache-test
  |> cache: `
    ttl: 10
    enabled: true
  `
  |> jq: `{
    message: "Hello from cache test!",
    timestamp: now,
    random: (now % 1000)
  }`

GET /no-cache-test  
  |> jq: `{
    message: "No cache here",
    timestamp: now,
    random: (now % 1000)
  }`

GET /slow-cached-test
  |> cache: `
    ttl: 30
    enabled: true
  `
  |> jq: `{ sqlParams: [] }`
  |> pg: `SELECT pg_sleep(0.25), 'Slow database operation completed!' as message, now() as timestamp`
  |> jq: `{
    message: .data.rows[0].message,
    timestamp: .data.rows[0].timestamp,
    cached: true,
    note: "This query sleeps for 250ms - should be fast on cache hit!"
  }`

GET /slow-uncached-test
  |> jq: `{ sqlParams: [] }`
  |> pg: `SELECT pg_sleep(0.25), 'Slow database operation completed!' as message, now() as timestamp`
  |> jq: `{
    message: .data.rows[0].message,
    timestamp: .data.rows[0].timestamp,
    cached: false,
    note: "This query sleeps for 250ms - always slow!"
  }`

GET /very-slow-cached-test
  |> cache: `
    ttl: 60
    enabled: true
  `
  |> jq: `{ sqlParams: [] }`
  |> pg: `SELECT pg_sleep(1.0), 'Very slow database operation completed!' as message, now() as timestamp, random() as random_value`
  |> jq: `{
    message: .data.rows[0].message,
    timestamp: .data.rows[0].timestamp,
    random_value: .data.rows[0].random_value,
    cached: true,
    note: "This query sleeps for 1 second - cache makes a huge difference!"
  }`

GET /user/:id/profile
  |> cache: `
    keyTemplate: user-profile-{params.id}
    ttl: 30
    enabled: true
  `
  |> jq: `{ sqlParams: [.params.id] }`
  |> pg: `SELECT pg_sleep(0.5), $1 as user_id, 'User profile data' as profile_type, now() as fetched_at`
  |> jq: `{
    user_id: .data.rows[0].user_id,
    profile_type: .data.rows[0].profile_type,
    fetched_at: .data.rows[0].fetched_at,
    cache_key_used: "user-profile-" + (.originalRequest.params.id | tostring),
    note: "Cache key includes user ID from URL parameter"
  }`

GET /api/search
  |> log: `level: debug, includeBody: true, includeHeaders: true`
  |> cache: `
    keyTemplate: search-{query.q}-{query.category}
    ttl: 15
    enabled: true
  `
  |> jq: `{ 
    sqlParams: [.query.q // "default", .query.category // "all"],
    search_term: .query.q,
    search_category: .query.category
  }`
  |> pg: `SELECT pg_sleep(0.3), $1 as term, $2 as category, 'Search results' as result_type, now() as searched_at`
  |> debug: `level: debug, includeBody: true, includeHeaders: true`
  |> jq: `{
    search_term: .data.rows[0].term,
    category: .data.rows[0].category,
    result_type: .data.rows[0].result_type,
    searched_at: .data.rows[0].searched_at,
    cache_key_used: "search-" + (.originalRequest.query.q | tostring) + "-" + (.originalRequest.query.category | tostring),
    note: "Cache key varies by search term and category query parameters"
  }`

config log {
  enabled: true
  format: "json"
  level: "debug"
  includeBody: false
  includeHeaders: true
  maxBodySize: 1024
  timestamp: true
}

  
GET /api/users/:id
  |> log: `level: debug, includeBody: true, includeHeaders: true`
  |> pg: `SELECT * FROM users WHERE id = $1`

## Todos App

# Default partials to avoid missing-partial errors and enable overrides
handlebars title = `Default Title`
handlebars headExtras = ``
handlebars content = `Default content`
handlebars footerScripts = ``
handlebars pageTitle = `Page Title`
handlebars pageContent = ``
handlebars authHeader = ``

handlebars baseLayout = `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{{> title}}</title>
  <script src="https://unpkg.com/htmx.org@1.9.10"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  {{> headExtras}}
</head>
<body class="bg-gray-100 font-sans">
  {{> content}}
  {{> footerScripts}}
</body>
</html>
`

handlebars authLayout = `
{{#*inline "authHeader"}}
  <div class="flex justify-between items-center border-b-2 border-blue-500 pb-3 mb-6">
    <h1 class="text-3xl font-bold text-gray-800">{{> pageTitle}}</h1>
    <div class="flex items-center space-x-4">
      <span class="text-gray-600">Welcome, {{user.login}}!</span>
      <button hx-post="/logout" hx-swap="none" hx-on::after-request="window.location.href='/login-page'" class="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors">Logout</button>
    </div>
  </div>
{{/inline}}
{{#*inline "content"}}
  <div class="max-w-4xl mx-auto p-6">
    <div class="bg-white p-6 rounded-lg shadow-md">
      {{> authHeader}}
      {{> pageContent}}
    </div>
  </div>
{{/inline}}
{{> baseLayout}}
`
POST /login
  |> validate: `{
    login: string(3..50),
    password: string(6..100)
  }`
  |> auth: "login"
  |> result
    ok(200):
      |> jq: `{
        success: true,
        message: "Login successful",
        user: {
          id: .user.id | tostring,
          login: .user.login,
          email: .user.email,
          type: .user.type
        }
      }`
    validationError(400):
      |> jq: `{
        success: false,
        error: "Validation failed",
        field: .errors[0].context,
        message: .errors[0].message
      }`
      |> handlebars: `
        <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4" role="alert">
          <strong class="font-bold">Validation Error:</strong>
          <span class="block sm:inline">{{message}}</span>
        </div>
      `
    authError(401):
      |> jq: `{
        success: false,
        error: "Login failed",
        message: .errors[0].message,
        context: .errors[0].context,
        fullError: .errors[0]
      }`
      |> handlebars: `
        <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4" role="alert">
          <strong class="font-bold">Login Failed:</strong>
          <span class="block sm:inline">{{message}}</span>
          {{#context}}<br><small>Context: {{context}}</small>{{/context}}
        </div>
      `

POST /logout
  |> auth: "logout"
  |> result
    ok(200):
      |> jq: `{
        success: true,
        message: "Logged out successfully"
      }`
    authError(401):
      |> jq: `{
        success: false,
        error: "Logout failed",
        message: .errors[0].message
      }`

POST /register
  |> validate: `{
    login: string(3..50),
    email: email,
    password: string(8..100)
  }`
  |> auth: "register"
  |> result
    ok(201):
      |> jq: `{
        success: true,
        message: "Registration successful"
      }`
      |> handlebars: `
        <div class="bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded mb-4" role="alert">
          <strong class="font-bold">Success!</strong>
          <span class="block sm:inline">Account created successfully. Redirecting to login...</span>
        </div>
      `
    validationError(400):
      |> jq: `{
        success: false,
        error: "Validation failed",
        field: .errors[0].context,
        message: .errors[0].message
      }`
      |> handlebars: `
        <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4" role="alert">
          <strong class="font-bold">Validation Error:</strong>
          <span class="block sm:inline">{{message}}</span>
        </div>
      `
    authError(409):
      |> jq: `{
        success: false,
        error: "Registration failed",
        message: .errors[0].message
      }`
      |> handlebars: `
        <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4" role="alert">
          <strong class="font-bold">Registration Failed:</strong>
          <span class="block sm:inline">{{message}}</span>
        </div>
      `

GET /login-page
  |> jq: `{
    pageTitle: "Login - Todo App",
    message: "Please log in to access your todos"
  }`
  |> handlebars: `
  {{#*inline "content"}}
    <body class="bg-gray-100 font-sans">
      <div class="max-w-md mx-auto mt-20 p-6">
        <div class="bg-white p-8 rounded-lg shadow-md">
          <div class="text-center mb-8">
            <h1 class="text-3xl font-bold text-gray-800 mb-2">Welcome Back</h1>
            <p class="text-gray-600">{{message}}</p>
          </div>
          
          <div id="login-response" class="mb-4"></div>
          
          <form hx-post="/login" hx-target="#login-response" hx-swap="innerHTML" class="space-y-4">
            <div>
              <label for="login" class="block text-sm font-medium text-gray-700 mb-1">Username</label>
              <input type="text" id="login" name="login" required class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" placeholder="Enter your username">
            </div>
            <div>
              <label for="password" class="block text-sm font-medium text-gray-700 mb-1">Password</label>
              <input type="password" id="password" name="password" required class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" placeholder="Enter your password">
            </div>
            <button type="submit" class="w-full bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors">
              Sign In
            </button>
          </form>
          
          <div class="mt-6 text-center">
            <p class="text-sm text-gray-600">
              Don't have an account? 
              <a href="/register-page" class="text-blue-500 hover:text-blue-600 font-medium">Sign up</a>
            </p>
          </div>
          
          <div class="mt-4 text-center">
            <a href="/hello" class="text-sm text-gray-500 hover:text-gray-700">← Back to Home</a>
          </div>
        </div>
      </div>
      
      <script>
        // Redirect to todos on successful login
        document.body.addEventListener('htmx:afterRequest', function(event) {
          if (event.detail.xhr.status === 200 && event.detail.target.id === 'login-response') {
            try {
              const response = JSON.parse(event.detail.xhr.responseText);
              if (response.success) {
                window.location.href = '/todos';
              }
            } catch (e) {
              // If not JSON, might be an error message
            }
          }
        });
      </script>
    <!-- content -->
  {{/inline}}
  {{> baseLayout}}
  `

GET /register-page
  |> jq: `{
    pageTitle: "Register - Todo App",
    message: "Create your account to get started"
  }`
  |> handlebars: `
  {{#*inline "content"}}
      <div class="max-w-md mx-auto mt-20 p-6">
        <div class="bg-white p-8 rounded-lg shadow-md">
          <div class="text-center mb-8">
            <h1 class="text-3xl font-bold text-gray-800 mb-2">Create Account</h1>
            <p class="text-gray-600">{{message}}</p>
          </div>
          
          <div id="register-response" class="mb-4"></div>
          
          <form hx-post="/register" hx-target="#register-response" hx-swap="innerHTML" class="space-y-4">
            <div>
              <label for="login" class="block text-sm font-medium text-gray-700 mb-1">Username</label>
              <input type="text" id="login" name="login" required class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" placeholder="Choose a username (3-50 chars)">
            </div>
            <div>
              <label for="email" class="block text-sm font-medium text-gray-700 mb-1">Email</label>
              <input type="email" id="email" name="email" required class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" placeholder="Enter your email">
            </div>
            <div>
              <label for="password" class="block text-sm font-medium text-gray-700 mb-1">Password</label>
              <input type="password" id="password" name="password" required class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" placeholder="Choose a password (8+ chars)">
            </div>
            <button type="submit" class="w-full bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors">
              Create Account
            </button>
          </form>
          
          <div class="mt-6 text-center">
            <p class="text-sm text-gray-600">
              Already have an account? 
              <a href="/login-page" class="text-blue-500 hover:text-blue-600 font-medium">Sign in</a>
            </p>
          </div>
          
          <div class="mt-4 text-center">
            <a href="/hello" class="text-sm text-gray-500 hover:text-gray-700">← Back to Home</a>
          </div>
        </div>
      </div>
      
      <script>
        // Redirect to login on successful registration
        document.body.addEventListener('htmx:afterRequest', function(event) {
          if (event.detail.xhr.status === 200 && event.detail.target.id === 'register-response') {
            try {
              const response = JSON.parse(event.detail.xhr.responseText);
              if (response.success) {
                window.location.href = '/login-page';
              }
            } catch (e) {
              // If not JSON, might be an error message
            }
          }
        });
      </script>
  {{/inline}}
  {{> baseLayout}}
  `

handlebars loginRequiredLayout = `
{{#*inline "title"}}Login Required{{/inline}}
{{#*inline "content"}}
    <div class="max-w-md mx-auto mt-20 p-6">
      <div class="bg-white p-8 rounded-lg shadow-md text-center">
        <div class="mb-6">
          <svg class="mx-auto h-16 w-16 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"/>
          </svg>
        </div>
        <h1 class="text-2xl font-bold text-gray-800 mb-4">Authentication Required</h1>
        <p class="text-gray-600 mb-6">You need to log in to access your todo list.</p>
        <div class="space-y-3">
          <a href="/login-page" class="block w-full bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors">Go to Login</a>
          <a href="/hello" class="block w-full bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors">Go to Home</a>
        </div>
      </div>
    </div>
{{/inline}}
{{> baseLayout}}
`

handlebars errorAlert = `
<div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4 mt-4" role="alert">
  <strong class="font-bold">{{> errorTitle}}:</strong>
  <span class="block sm:inline">{{> errorMessage}}</span>
  </div>
`

GET /todos
  |> auth: "required"
  |> result
    ok(200):
      |> jq: `. + { sqlParams: [.user.id] }`
      |> pg: `SELECT id, title, completed, created_at, updated_at FROM todos WHERE user_id = $1 ORDER BY created_at DESC`
      |> jq: `. + {
        todos: .data.rows | map(. + {id: (.id | tostring)}),
        pageTitle: "Todo List"
      }`
      |> handlebars: `
        {{#*inline "title"}}{{pageTitle}}{{/inline}}
        {{#*inline "pageTitle"}}{{pageTitle}} - {{user.login}}{{/inline}}
        {{#*inline "pageContent"}}
            <div class="bg-gray-50 p-6 rounded-lg mb-6">
              <h3 class="text-lg font-semibold mb-4">Add New Todo</h3>
              <div id="form-errors"></div>
              <form hx-post="/todos/add" hx-target="#form-response" hx-swap="innerHTML" hx-on::response-error="document.getElementById('form-response').innerHTML = event.detail.xhr.responseText" class="space-y-4">
                <div>
                  <label for="title" class="block text-sm font-medium text-gray-700 mb-1">Title * (3-30 characters)</label>
                  <input type="text" id="title" name="title" required class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                </div>
                <button type="submit" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors">Add Todo</button>
              </form>
              <div id="form-response"></div>
            </div>
            
            <ul id="todo-list" class="space-y-3">
              {{#each todos}}
                {{> todoItemPartial}}
              {{else}}
                <li class="text-center text-gray-500 italic py-10">
                  <p>No todos yet. Add your first todo above!</p>
                </li>
              {{/each}}
            </ul>
        {{/inline}}
        {{> authLayout}}
      `
    authError(401):
      |> handlebars: `{{>loginRequiredLayout}}`

POST /todos/add
  |> auth: "required"
  |> result
    ok(200):
      |> validate: `
        title: string(3..30)
      `
      |> jq: `. + { 
        sqlParams: [.body.title, false, .user.id]
      }`
      |> pg: `INSERT INTO todos (title, completed, user_id) VALUES ($1, $2, $3) RETURNING *`
      |> result
        ok(201):
          |> jq: `(.data.rows[0] | . + {id: (.id | tostring)})`
          |> handlebars: `
            <div hx-swap-oob="afterbegin:#todo-list">
              {{>todoItemPartial}}
            </div>
            <input type="text" id="title" name="title" required class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" value="" hx-swap-oob="true">
          `
        validationError(400):
          |> jq: `{
            error: "Validation failed",
            field: .errors[0].field,
            rule: .errors[0].rule,
            message: .errors[0].message
          }`
          |> handlebars: `
            {{#*inline "errorTitle"}}Validation Error{{/inline}}
            {{#*inline "errorMessage"}}{{message}}{{/inline}}
            {{> errorAlert}}
          `
    authError(401):
      |> handlebars: `
        {{<errorAlert}}
          {{$errorTitle}}Authentication Required{{/errorTitle}}
          {{$errorMessage}}Please log in to add todos.{{/errorMessage}}
        {{/errorAlert}}
      `

POST /todos/:id/toggle
  |> auth: "required"
  |> result
    ok(200):
      |> jq: `{ sqlParams: [.params.id, .user.id], todoId: .params.id }`
      |> pg: `SELECT * FROM todos WHERE id = $1 AND user_id = $2`
      |> jq: `{ 
        sqlParams: [(.data.rows[0].completed | not), .todoId],
        currentTodo: .data.rows[0]
      }`
      |> pg: `UPDATE todos SET completed = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2 RETURNING *`
      |> jq: `.data.rows[0]`
      |> handlebars: `{{> todoItemPartial}}`
    authError(401):
       |> handlebars: `
        {{#*inline "errorTitle"}}Authentication Required{{/inline}}
        {{#*inline "errorMessage"}}Please log in to modify todos.{{/inline}}
        {{> errorAlert}}
      `

DELETE /todos/:id
  |> auth: "required"
  |> result
    ok(200):
      |> jq: `{ sqlParams: [.params.id, .user.id] }`
      |> pg: `DELETE FROM todos WHERE id = $1 AND user_id = $2`
      |> handlebars: ``
    authError(401):
       |> handlebars: `
        {{#*inline "errorTitle"}}Authentication Required{{/inline}}
        {{#*inline "errorMessage"}}Please log in to delete todos.{{/inline}}
        {{> errorAlert}}
      `

handlebars todoItemPartial = `
  <li class="{{#if completed}}bg-green-50 border-l-4 border-green-400{{else}}bg-gray-50 border-l-4 border-blue-400{{/if}} p-4 rounded-lg flex justify-between items-start">
    <div class="flex-1">
      <div class="{{#if completed}}text-gray-500 line-through{{else}}text-gray-800 font-medium{{/if}}">{{title}}</div>
      <div class="text-sm text-gray-500 mt-1">Created: {{created_at}}</div>
    </div>
    <div class="flex space-x-2 ml-4">
      {{#if completed}}
        <button hx-post="/todos/{{id}}/toggle" hx-target="closest li" hx-swap="outerHTML" class="px-3 py-1 text-sm bg-gray-500 hover:bg-gray-600 text-white rounded transition-colors">Mark Incomplete</button>
      {{else}}
        <button hx-post="/todos/{{id}}/toggle" hx-target="closest li" hx-swap="outerHTML" class="px-3 py-1 text-sm bg-green-500 hover:bg-green-600 text-white rounded transition-colors">Mark Complete</button>
      {{/if}}
      <button hx-delete="/todos/{{id}}" hx-target="closest li" hx-swap="outerHTML" hx-confirm="Are you sure you want to delete this todo?" class="px-3 py-1 text-sm bg-red-500 hover:bg-red-600 text-white rounded transition-colors">Delete</button>
    </div>
  </li>
`

## Test routes for new resultName functionality

# Test explicit resultName functionality
GET /test/named-query/:id
  |> jq: `{ resultName: "userProfile" }`
  |> pg: `SELECT 1 as id, 'Test User' as name, 'test@example.com' as email`
  |> jq: `{ user: .data.userProfile }`

# Test multiple named results
GET /test/multiple/:id
  |> jq: `{ resultName: "userInfo" }`
  |> pg: `SELECT 1 as id, 'Test User' as name`
  |> jq: `{ resultName: "userTeams" }`
  |> pg: `SELECT 1 as id, 'Engineering' as name UNION SELECT 2 as id, 'Product' as name`
  |> jq: `{ 
      profile: .data.userInfo,
      teams: .data.userTeams
    }`

# Test auto-naming with variables (should now use variable name as result key)
pg getUserQuery = `SELECT 1 as id, 'Auto Named User' as name`
pg getTeamsQuery = `SELECT 1 as id, 'Auto Team' as name`

GET /test/auto-naming/:id
  |> pg: getUserQuery
  |> pg: getTeamsQuery
  |> jq: `{ 
      user: .data.getUserQuery,
      teams: .data.getTeamsQuery,
      hasUserData: (.data.getUserQuery != null),
      hasTeamsData: (.data.getTeamsQuery != null)
    }`

# Test that legacy behavior is preserved (no resultName, no variable)
GET /test/legacy/:id
  |> pg: `SELECT 1 as id, 'Legacy User' as name`

# Test Fetch Middleware

## Basic GET request
GET /test-fetch
  |> fetch: `https://api.github.com/zen`

## GET with fetchUrl override
GET /test-fetch-override
  |> jq: `{ fetchUrl: "https://api.github.com/zen" }`
  |> fetch: `https://example.com`

## POST with body
GET /test-fetch-post
  |> jq: `{
    fetchMethod: "POST",
    fetchBody: { name: "test", value: 123 },
    fetchHeaders: { "Content-Type": "application/json" }
  }`
  |> fetch: `https://api.github.com/zen`

## Named result
GET /test-fetch-named
  |> jq: `{ resultName: "apiCall" }`
  |> fetch: `https://api.github.com/zen`
  |> jq: `{ 
    response: .data.apiCall.response,
    status: .data.apiCall.status,
    success: (.data.apiCall.status == 200)
  }`

## Test error handling
GET /test-fetch-error
  |> fetch: `https://nonexistent-domain-12345.com`

## Test timeout (if httpbin is slow)
GET /test-fetch-timeout
  |> jq: `{ fetchTimeout: 1 }`
  |> fetch: `https://httpbin.org/delay/5`

## Test Lua Script Preloading Performance
# These routes test the performance improvements from preloading Lua scripts

GET /lua-preload-test
  |> lua: `

    local numbers = {10, 20, 30, 40, 50}
    local sum = mathUtils.sum(numbers)
    local avg = mathUtils.average(numbers)
    local fib15 = mathUtils.fibonacci(15)
    local primeCount = mathUtils.countPrimes(100)

    return {
      message = "Successfully loaded preloaded Lua module",
      numbers = numbers,
      sum = sum,
      average = avg,
      fibonacci_15 = fib15,
      primes_up_to_100 = primeCount,
      note = "This uses preloaded scripts (zero filesystem I/O on request path!)"
    }
  `

GET /lua-preload-bench
  |> lua: `


    -- Do some calculations
    local results = {}
    for i = 1, 20 do
      results[i] = mathUtils.fibonacci(i)
    end

    local primes = mathUtils.countPrimes(500)

    return {
      message = "Lua script preload benchmark",
      fibonacci_sequence = results,
      primes_up_to_500 = primes,
      performance_note = "Script loaded from memory, not filesystem!"
    }
  `

GET /lua-script-stress
  |> lua: `
    -- Stress test: require script many times in a single request
    local iterations = 50
    local results = {}

    for i = 1, iterations do
      results[i] = mathUtils.fibonacci(10)
    end

    return {
      message = "Stress test completed",
      iterations = iterations,
      note = "Required script 50 times - all from memory cache!",
      sample_results = {results[1], results[25], results[50]}
    }
  `

## Tags Feature Demo (v2.0+)

# Tags can be used for environment-specific code, feature flags, or execution hints
# Syntax: @tagname, @!negated, @tag(arg1,arg2)

pipeline taggedExample =
  |> jq: `{ message: "Production ready" }` @env(production)
  |> log: `level: info` @env(production) @async(background)
  |> pg: `SELECT * FROM users LIMIT 10` @env(development) @flag(new-ui)
  |> cache: `ttl: 300` @!env(development)
  |> handlebars: `<div>{{message}}</div>` @flag(beta,staff)

GET /tagged-route
  |> jq: `{ env: "production", debug: false }` @env(production)
  |> jq: `{ env: "development", debug: true }` @env(development)
  |> log: `level: debug` @!env(production) @async(logger)
  |> handlebars: `<pre>{{env}}: debug={{debug}}</pre>`

# Example use cases for tags:
# @env(production), @env(development), @env(staging) - Environment-specific steps
# @!env(production) - Run in all environments except production
# @async(worker) - Execution hints for async processing
# @flag(feature-name) - Feature flags
# @flag(beta,staff) - Multiple feature flag args

# Set environment with: WEBPIPE_ENV=production or WEBPIPE_ENV=development

## Async/Join Feature Demo (v2.0+)

GET /dashboard-sync
  |> fetch: `https://jsonplaceholder.typicode.com/users/1`
  |> jq: `{ user: .data.response }`
  |> fetch: `https://jsonplaceholder.typicode.com/posts?userId=1&_limit=5`
  |> jq: `. + { posts: .data.response }`
  |> fetch: `https://jsonplaceholder.typicode.com/todos?userId=1&_limit=5`
  |> jq: `. + { todos: .data.response }`
  |> jq: `{
    pageTitle: "User Dashboard (Sync)",
    user: .user,
    recentPosts: .posts,
    pendingTodos: .todos | map(select(.completed == false))
  }`
  |> handlebars: `
    <html>
      <head><title>{{pageTitle}}</title></head>
      <body>
        <h1>{{pageTitle}}</h1>

        <section>
          <h2>User Info</h2>
          <p><strong>Name:</strong> {{user.name}}</p>
          <p><strong>Email:</strong> {{user.email}}</p>
          <p><strong>Company:</strong> {{user.company.name}}</p>
        </section>

        <section>
          <h2>Recent Posts</h2>
          <ul>
            {{#each recentPosts}}
              <li><strong>{{title}}</strong><br>{{body}}</li>
            {{/each}}
          </ul>
        </section>

        <section>
          <h2>Pending Todos</h2>
          <ul>
            {{#each pendingTodos}}
              <li>{{title}}</li>
            {{/each}}
          </ul>
        </section>
      </body>
    </html>
  `

GET /dashboard
  |> fetch: `https://jsonplaceholder.typicode.com/users/1` @async(user)
  |> fetch: `https://jsonplaceholder.typicode.com/posts?userId=1&_limit=5` @async(posts)
  |> fetch: `https://jsonplaceholder.typicode.com/todos?userId=1&_limit=5` @async(todos)
  |> jq: `{
    pageTitle: "User Dashboard",
    timestamp: now
  }`
  |> join: `user,posts,todos`
  |> jq: `{
    page: .pageTitle,
    loadedAt: .timestamp,
    user: .async.user.data.response,
    recentPosts: .async.posts.data.response,
    pendingTodos: .async.todos.data.response
  }`
  |> handlebars: `
    <html>
      <head><title>{{page}}</title></head>
      <body>
        <h1>{{page}}</h1>
        <p>Loaded at: {{loadedAt}}</p>

        <section>
          <h2>User Info</h2>
          <p><strong>Name:</strong> {{user.name}}</p>
          <p><strong>Email:</strong> {{user.email}}</p>
          <p><strong>Company:</strong> {{user.company.name}}</p>
        </section>

        <section>
          <h2>Recent Posts</h2>
          <ul>
            {{#each recentPosts}}
              <li><strong>{{title}}</strong><br>{{body}}</li>
            {{/each}}
          </ul>
        </section>

        <section>
          <h2>Pending Todos</h2>
          <ul>
            {{#each pendingTodos}}
              <li>{{title}}</li>
            {{/each}}
          </ul>
        </section>
      </body>
    </html>
  `

GET /weather/:city
  |> jq: `{
    fetchUrl: "https://api.open-meteo.com/v1/forecast?latitude=52.52&longitude=13.41&current_weather=true",
    fetchMethod: "GET"
  }` 
  |> fetch: `_` @async(openmeteo)
  |> jq: `{
    fetchUrl: "https://goweather.herokuapp.com/weather/" + .params.city,
    fetchMethod: "GET"
  }` 
  |> fetch: `_` @async(goweather)
  |> join: `openmeteo,goweather`
  |> jq: `{
    city: .params.city,
    temperature: (.async.openmeteo.data.response.current_weather.temperature // .async.goweather.data.temperature),
    description: (.async.goweather.data.response.description // "Data from Open-Meteo"),
    sources: {
      openmeteo: (.async.openmeteo.error // "success"),
      goweather: (.async.goweather.error // "success")
    }
  }`
  |> handlebars: `
    <h1>Weather for {{city}}</h1>
    <p><strong>Temperature:</strong> {{temperature}}°C</p>
    <p><strong>Conditions:</strong> {{description}}</p>
    <details>
      <summary>API Sources</summary>
      <ul>
        <li>Open-Meteo: {{sources.openmeteo}}</li>
        <li>GoWeather: {{sources.goweather}}</li>
      </ul>
    </details>
  `

GET /parallel-api-demo
  |> fetch: `https://api.github.com/users/github` @async(github)
  |> fetch: `https://api.coindesk.com/v1/bpi/currentprice.json` @async(bitcoin)
  |> fetch: `https://official-joke-api.appspot.com/random_joke` @async(joke)
  |> join: `["github","bitcoin","joke"]`
  |> jq: `{
    githubUser: .async.github.data.response.login,
    bitcoinPrice: .async.bitcoin.data.response.bpi.USD.rate,
    randomJoke: .async.joke.data.response.setup + " - " + .async.joke.data.response.punchline
  }`

GET /slow-sync
  |> lua: `
    -- Simulate ~2s delay and preserve prior fields
    local start = os.time()
    while os.time() - start < 2 do end
    local out = {}
    if type(request) == "table" then
      for k, v in pairs(request) do out[k] = v end
    end
    out.data = { response = { url = "lua://delay/2/step1" } }
    return out
  `
  |> jq: `{ first: .data.response, step: "1/3" }`
  |> lua: `
    -- Simulate ~2s delay and preserve prior fields
    local start = os.time()
    while os.time() - start < 2 do end
    local out = {}
    if type(request) == "table" then
      for k, v in pairs(request) do out[k] = v end
    end
    out.data = { response = { url = "lua://delay/2/step2" } }
    return out
  `
  |> jq: `. + { second: .data.response, step: "2/3" }`
  |> lua: `
    -- Simulate ~2s delay and preserve prior fields
    local start = os.time()
    while os.time() - start < 2 do end
    local out = {}
    if type(request) == "table" then
      for k, v in pairs(request) do out[k] = v end
    end
    out.data = { response = { url = "lua://delay/2/step3" } }
    return out
  `
  |> jq: `. + { third: .data.response, step: "3/3" }`
  |> jq: `{
    message: "All requests completed synchronously",
    totalTime: "~6 seconds (2+2+2)",
    results: [.first.url, .second.url, .third.url]
  }`

GET /slow-async
  |> lua: `
    -- Simulate ~2s delay and preserve prior fields
    local start = os.time()
    while os.time() - start < 2 do end
    local out = {}
    if type(request) == "table" then
      for k, v in pairs(request) do out[k] = v end
    end
    out.data = { response = { url = "lua://delay/2/step1" } }
    return out
  ` @async(req1)
  |> lua: `
    -- Simulate ~2s delay and preserve prior fields
    local start = os.time()
    while os.time() - start < 2 do end
    local out = {}
    if type(request) == "table" then
      for k, v in pairs(request) do out[k] = v end
    end
    out.data = { response = { url = "lua://delay/2/step2" } }
    return out
  ` @async(req2)
  |> lua: `
    -- Simulate ~2s delay and preserve prior fields
    local start = os.time()
    while os.time() - start < 2 do end
    local out = {}
    if type(request) == "table" then
      for k, v in pairs(request) do out[k] = v end
    end
    out.data = { response = { url = "lua://delay/2/step3" } }
    return out
  ` @async(req3)
  |> join: `req1,req2,req3`
  |> jq: `{
    message: "All requests completed in parallel",
    totalTime: "~2 seconds (all parallel)",
    results: [
      .async.req1.data.response.url,
      .async.req2.data.response.url,
      .async.req3.data.response.url
    ]
  }`

query todos =
  |> auth: "required"
  |> jq: `{ sqlParams: [.context.user.id] }`
  |> pg: `
    SELECT id, title, completed, created_at, updated_at
    FROM todos
    WHERE user_id = $1
    ORDER BY created_at DESC
  `
  |> jq: `.data.rows`


mutation toggleTodo =
  |> auth: "required"
  |> jq: `{ sqlParams: [.args.id, .context.user.id] }`
  |> pg: `
    UPDATE todos
    SET completed = NOT completed,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = $1 AND user_id = $2
    RETURNING *
  `
  |> jq: `.data.rows[0]`

## GraphQL Schema and Resolvers Demo

graphqlSchema = `
  type User {
    id: ID!
    name: String!
    email: String!
    createdAt: String!
  }

  type Post {
    id: ID!
    title: String!
    body: String!
    userId: Int!
    published: Boolean!
  }

  type Stats {
    totalUsers: Int!
    totalPosts: Int!
    activeUsers: Int!
  }

  type Query {
    currentTime: String!
    randomNumber: Int!
    users: [User!]!
    user(id: Int!): User
    posts(limit: Int): [Post!]!
    stats: Stats!
  }

  type Mutation {
    createPost(title: String!, body: String!): Post!
    updatePost(id: Int!, title: String, body: String): Post!
    deletePost(id: Int!): Boolean!
  }
`

# Query resolver: return current timestamp
query currentTime =
  |> pg: `SELECT NOW()::text as time`
  |> jq: `.data.rows[0].time`

# Query resolver: return a random number
query randomNumber =
  |> pg: `SELECT floor(random() * 1000)::int as number`
  |> jq: `.data.rows[0].number`

# Query resolver: return mock users
query users =
  |> pg: `
    SELECT
      id,
      'User ' || id as name,
      'user' || id || '@example.com' as email,
      NOW() - (id || ' days')::interval as "createdAt"
    FROM generate_series(1, 5) as id
  `
  |> jq: `.data.rows`

# Query resolver: return single user by ID
query user =
  |> jq: `{ sqlParams: [.id] }`
  |> pg: `
    SELECT
      $1 as id,
      'User ' || $1 as name,
      'user' || $1 || '@example.com' as email,
      NOW()::text as "createdAt"
  `
  |> jq: `.data.rows[0]`

# Query resolver: return mock posts with optional limit
query posts =
  |> jq: `{ sqlParams: [.limit // 10] }`
  |> pg: `
    SELECT
      id,
      'Post Title ' || id as title,
      'This is the body content for post ' || id as body,
      (id % 5) + 1 as "userId",
      (random() > 0.5) as published
    FROM generate_series(1, $1) as id
  `
  |> jq: `.data.rows`

# Query resolver: return aggregate stats
query stats =
  |> pg: `
    SELECT
      5 as "totalUsers",
      100 as "totalPosts",
      3 as "activeUsers"
  `
  |> jq: `.data.rows[0]`

# Mutation resolver: create a post
mutation createPost =
  |> validate: `{
    title: string(5..100),
    body: string(10..500)
  }`
  |> jq: `{ sqlParams: [.title, .body] }`
  |> pg: `
    SELECT
      floor(random() * 1000)::int as id,
      $1 as title,
      $2 as body,
      1 as "userId",
      true as published
  `
  |> jq: `.data.rows[0]`

# Mutation resolver: update a post
mutation updatePost =
  |> validate: `{
    id: number
  }`
  |> jq: `{ sqlParams: [.id, .title // "Updated Title", .body // "Updated body"] }`
  |> pg: `
    SELECT
      $1 as id,
      $2 as title,
      $3 as body,
      1 as "userId",
      true as published
  `
  |> jq: `.data.rows[0]`

# Mutation resolver: delete a post
mutation deletePost =
  |> jq: `{ sqlParams: [.id] }`
  |> pg: `SELECT $1 as id`
  |> jq: `(.data.rows | length > 0)`

# GraphQL endpoint: execute GraphQL queries
POST /graphql
  |> jq: `{ graphqlParams: .variables }`
  |> graphql: `.query`

# Test route: simple query
GET /test-graphql-simple
  |> graphql: `
    query {
      currentTime
      randomNumber
    }
  `

# Test route: query with arguments
GET /test-graphql-args
  |> jq: `.graphqlParams = { id: 1, limit: 3 }`
  |> graphql: `
    query($id: Int!, $limit: Int) {
      user(id: $id) {
        id
        name
        email
      }
      posts(limit: $limit) {
        id
        title
      }
    }
  `

graphql testMutation = `
  mutation($title: String!, $body: String!) {
    createPost(title: $title, body: $body) {
      id
      title
      body
    }
  }
`

POST /test-graphql-mutation
  |> jq: `.graphqlParams = { title: .body.title, body: .body.body }`
  |> graphql: testMutation

# Test route: multiple queries with resultName
GET /test-graphql-multi
  |> jq: `.resultName = "time"`
  |> graphql: `query { currentTime }`
  |> jq: `.resultName = "users"`
  |> graphql: `query { users { id name email } }`
  |> jq: `.resultName = "stats"`
  |> graphql: `query { stats { totalUsers totalPosts activeUsers } }`

# Test route: single query with users (for debugging)
GET /test-graphql-users-only
  |> graphql: `query { users { id name email } }`

# Test route: single graphql call with resultName
GET /test-graphql-single-resultname
  |> jq: `.resultName = "users"`
  |> graphql: `query { users { id name email } }`

# Test route: test just first step of multi
GET /test-graphql-first-step
  |> jq: `.resultName = "time"`
  |> graphql: `query { currentTime }`

# Test route: parallel GraphQL queries with async and join
# Fires multiple independent GraphQL queries in parallel for maximum performance
GET /test-graphql-async-parallel
  |> graphql: `query { users { id name email } }` @async(usersQuery)
  |> graphql: `query { stats { totalUsers totalPosts activeUsers } }` @async(statsQuery)
  |> graphql: `query { posts(limit: 5) { id title userId published } }` @async(postsQuery)
  |> graphql: `query { currentTime randomNumber }` @async(timeQuery)
  |> join: `usersQuery, statsQuery, postsQuery, timeQuery`
  |> jq: `{
    dashboard: {
      loadedAt: .async.timeQuery.data.currentTime,
      randomNumber: .async.timeQuery.data.randomNumber,
      statistics: .async.statsQuery.data.stats,
      users: .async.usersQuery.data.users,
      recentPosts: .async.postsQuery.data.posts,
      metadata: {
        queriesExecuted: 4,
        executionMode: "parallel"
      }
    }
  }`

# Comparison route: same queries executed synchronously (slower)
GET /test-graphql-sync-sequential
  |> jq: `.resultName = "users"`
  |> graphql: `query { users { id name email } }`
  |> jq: `.resultName = "stats"`
  |> graphql: `query { stats { totalUsers totalPosts activeUsers } }`
  |> jq: `.resultName = "posts"`
  |> graphql: `query { posts(limit: 5) { id title userId published } }`
  |> jq: `.resultName = "time"`
  |> graphql: `query { currentTime randomNumber }`
  |> jq: `{
    dashboard: {
      loadedAt: .data.time.currentTime,
      randomNumber: .data.time.randomNumber,
      statistics: .data.stats.stats,
      users: .data.users.users,
      recentPosts: .data.posts.posts,
      metadata: {
        queriesExecuted: 4,
        executionMode: "sequential"
      }
    }
  }`

GET /ok
  |> jq: `.`

## Parallel pg_sleep Demo - Async Join Performance Test
# This demonstrates how 3 independent 2-second database sleeps complete in ~2 seconds total
# when executed in parallel via async/join, instead of ~6 seconds sequentially.

# Query resolvers that each sleep for 2 seconds
query slowQuery1 =
  |> pg: `SELECT pg_sleep(2), 'Query 1 complete' as result, NOW()::text as completed_at`
  |> jq: `.data.rows[0]`

query slowQuery2 =
  |> pg: `SELECT pg_sleep(2), 'Query 2 complete' as result, NOW()::text as completed_at`
  |> jq: `.data.rows[0]`

query slowQuery3 =
  |> pg: `SELECT pg_sleep(2), 'Query 3 complete' as result, NOW()::text as completed_at`
  |> jq: `.data.rows[0]`

graphql slowQuery1 = `query { slowQuery1 { result completed_at } }`
graphql slowQuery2 = `query { slowQuery2 { result completed_at } }`
graphql slowQuery3 = `query { slowQuery3 { result completed_at } }`

# Parallel execution route - should complete in ~2 seconds
GET /test-parallel-sleep
  |> graphql: slowQuery1 @async(q1)
  |> graphql: slowQuery2 @async(q2)
  |> graphql: slowQuery3 @async(q3)
  |> jq: `{ startedAt: now }`
  |> join: `q1, q2, q3`
  |> jq: `{ totalTime: (now - .startedAt) }`
  |> jq: `{
    totalTime: .totalTime,
    message: "All 3 queries with 2-second sleeps completed in parallel!",
    results: {
      query1: .async.q1.data.slowQuery1,
      query2: .async.q2.data.slowQuery2,
      query3: .async.q3.data.slowQuery3
    }
  }`

# Sequential execution route for comparison - should take ~6 seconds
GET /test-sequential-sleep
  |> jq: `{ startedAt: now }`
  |> jq: `.resultName = "q1"`
  |> graphql: slowQuery1
  |> jq: `.resultName = "q2"`
  |> graphql: slowQuery2
  |> jq: `.resultName = "q3"`
  |> graphql: slowQuery3
  |> jq: `{ totalTime: (now - .startedAt) }`
  |> jq: `{
    totalTime: .totalTime,
    message: "All 3 queries completed sequentially",
    results: {
      query1: .data.q1.slowQuery1,
      query2: .data.q2.slowQuery2,
      query3: .data.q3.slowQuery3
    }
  }`

## Feature Flags Demo (v2.0+)
# Demonstrates dynamic feature flags with 2/3 probability rollout

featureFlags =
  |> lua: `
    -- Enable "experimental-feature" flag 2/3rds of the time
    
    -- Generate random number between 0 and 1
    math.randomseed(os.time() * 1000 + (request.headers and request.headers["x-request-id"] and tonumber(request.headers["x-request-id"]) or 0))
    local rand = math.random()

    -- Enable flag if random value is less than 0.666 (2/3)
    -- Use new setFlag API
    setFlag("experimental-feature", (rand < 0.6666))

    -- Always enable beta flag for internal users
    if request.user and request.user.email and string.find(request.user.email, "@internal.com") then
      setFlag("beta-features", true)
    else
      setFlag("beta-features", false)
    end

    -- No need to return metadata anymore
    return {}
  `

GET /feature-test
  |> jq: `{ message: "Standard feature (no flag required)" }` @!flag(experimental-feature)
  |> jq: `{ message: "Experimental feature enabled!" }` @flag(experimental-feature)

GET /feature-gui
  |> jq: `{
    title: "Standard Dashboard",
    message: "Welcome to your dashboard",
    version: "1.0"
  }` @!flag(experimental-feature)
  |> handlebars: `
    <!DOCTYPE html>
    <html>
    <head>
      <title>{{title}}</title>
      <style>
        body { font-family: Arial, sans-serif; background: #f5f5f5; color: #333; padding: 40px; }
        .container { max-width: 800px; margin: 0 auto; background: white; padding: 30px; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px; }
        .info { background: #ecf0f1; padding: 15px; border-radius: 5px; margin-top: 20px; }
      </style>
    </head>
    <body>
      <div class="container">
        <h1>{{title}}</h1>
        <p>{{message}}</p>
        <div class="info">
          <strong>Version:</strong> {{version}}
        </div>
      </div>
    </body>
    </html>
  ` @!flag(experimental-feature)
  |> jq: `{
    title: "Experimental Dashboard",
    features: ["Real-time Analytics", "AI-Powered Insights", "Advanced Filtering"],
    theme: "modern"
  }` @flag(experimental-feature)
  |> handlebars: `
    <!DOCTYPE html>
    <html>
    <head>
      <title>{{title}}</title>
      <style>
        body { font-family: 'Segoe UI', sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 40px; }
        .container { max-width: 800px; margin: 0 auto; background: rgba(255,255,255,0.1); backdrop-filter: blur(10px); padding: 30px; border-radius: 15px; box-shadow: 0 8px 32px rgba(0,0,0,0.3); }
        h1 { font-size: 2.5em; margin-bottom: 10px; }
        .badge { background: #10b981; padding: 5px 15px; border-radius: 20px; font-size: 0.8em; display: inline-block; margin-bottom: 20px; }
        .features { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 30px; }
        .feature-card { background: rgba(255,255,255,0.2); padding: 20px; border-radius: 10px; text-align: center; transition: transform 0.2s; }
        .feature-card:hover { transform: translateY(-5px); }
      </style>
    </head>
    <body>
      <div class="container">
        <h1>{{title}}</h1>
        <span class="badge">EXPERIMENTAL</span>
        <p style="font-size: 1.2em; opacity: 0.9;">Experience the next generation of features</p>
        <div class="features">
          {{#each features}}
          <div class="feature-card">
            <strong>{{this}}</strong>
          </div>
          {{/each}}
        </div>
      </div>x
    </body>
    </html>
  ` @flag(experimental-feature)

GET /test-rate-limit
  |> rateLimit: `
    keyTemplate: ip-{ip}-route-{method}-{path}
    limit: 1
    window: 10s
  `
  |> jq: `{ message: "Rate limited" }`

## If/Else Feature Demo (v2.1+)
# Demonstrates the new implicit condition if/else syntax
# The condition is itself a pipeline, making it very powerful

# Test 1: Simple boolean condition
GET /test-if-simple
  |> jq: `{ count: 15 }`
  |> if
    |> jq: `.count > 10`
    then:
      |> jq: `{ status: "high", count: .count }`
    else:
      |> jq: `{ status: "low", count: .count }`

# Simple test without result step
GET /test-if-simple/:value
  |> jq: `{ value: (.params.value | tonumber) }`
  |> if
    |> jq: `.value > 50`
    then:
      |> jq: `{ category: "high", then: true }`
    else:
      |> jq: `{ category: "low", else: true }`
    end
  |> jq: `{ final: true, wrapped: . }`

# Test 2: Multi-step condition with external API check
pipeline protectedResource =
  |> jq: `{ message: "Access granted to protected resource" }`

GET /test-if-auth
  |> if
    |> jq: `{ authorized: true }`
    then:
      |> log: "Access Granted"
      |> pipeline: protectedResource
    else:
      |> jq: `{ error: "Unauthorized", status: 401 }`

# Test 3: If without else (pass-through behavior)
GET /test-if-no-else
  |> jq: `{ initial: "data", count: 7 }`
  |> if
    |> jq: `.count > 5`
    then:
      |> jq: `. + { modified: true, bonus: "high count" }`

# Test 4: Nested if blocks
GET /test-if-nested
  |> jq: `{ level: 12 }`
  # comment here
  |> if
    |> jq: `.level > 0`
    # comment here
    then:
      |> if
        |> jq: `.level > 10`
        then:
          |> jq: `. + { status: "high", tier: "premium" }`
        else:
          |> jq: `. + { status: "medium", tier: "standard" }`
    else:
      |> jq: `. + { status: "low", tier: "free" }`

# Test 5: Condition returns null (should be falsy)
GET /test-if-null
  |> if
    |> jq: `null`
    then:
      |> jq: `{ result: "should not see this" }`
    else:
      |> jq: `{ result: "null is falsy" }`

# Test 6: Condition returns false
GET /test-if-false
  |> if
    |> jq: `false`
    then:
      |> jq: `{ result: "should not see this" }`
    else:
      |> jq: `{ result: "false is falsy" }`

# Test 7: Condition returns object (should be truthy)
GET /test-if-object
  |> if
    |> jq: `{ some: "data" }`
    then:
      |> jq: `{ result: "objects are truthy" }`
    else:
      |> jq: `{ result: "should not see this" }`

# Test 8: Condition with database query
GET /test-if-db-check/:userId
  |> if
    |> jq: `{ sqlParams: [.params.userId] }`
    |> pg: `SELECT EXISTS(SELECT 1 FROM users WHERE id = $1 AND status = 'active') as active`
    |> jq: `.data.rows[0].active`
    then:
      |> jq: `{ message: "User is active", userId: .params.userId }`
    else:
      |> jq: `{ error: "User not found or inactive", userId: .params.userId }`

# Test 9: If/else with result branches
GET /test-if-with-result/:value
  |> jq: `{ value: (.params.value | tonumber) }`
  |> if
    |> jq: `.value > 50`
    then:
      |> jq: `{ category: "high", value: .value }`
    else:
      |> jq: `{ category: "low", value: .value }`
    end
  |> result
    ok(200):
      |> jq: `{ success: true, data: . }`

# Test 10: Complex condition with multiple steps
GET /test-if-complex
  |> jq: `{ userId: 123 }`
  |> if
    |> jq: `{ sqlParams: [.userId] }`
    |> pg: `SELECT COUNT(*) as count FROM users WHERE id = $1`
    |> jq: `.data.rows[0].count > 0`
    then:
      |> jq: `{ authorized: true, message: "User found in database" }`
    else:
      |> jq: `{ authorized: false, message: "User not found" }`

describe "if/else feature"
  it "executes then branch when condition is true"
    when calling GET /test-if-simple
    then output `.status` equals "high"
    and output `.count` equals 15

  it "executes else branch when condition is false"
    when calling GET /test-if-false
    then output `.result` equals "false is falsy"

  it "treats null as falsy"
    when calling GET /test-if-null
    then output `.result` equals "null is falsy"

  it "treats objects as truthy"
    when calling GET /test-if-object
    then output `.result` equals "objects are truthy"

# ========================================
# Context Injection Tests
# ========================================
# Test JQ middleware with $context
GET /test-context-jq
  |> jq: `{
    has_context: ($context != null),
    has_flags: ($context.flags != null),
    message: "JQ context works"
  }`

# Test Lua middleware with context variable
GET /test-context-lua
  |> lua: `
    return {
      has_context = (context ~= nil),
      has_flags = (context.flags ~= nil),
      message = "Lua context works"
    }
  `

# Test Handlebars middleware with context
GET /test-context-handlebars
  |> jq: `{ name: "WebPipe" }`
  |> handlebars: `<p>Hello {{name}}! Env: {{context.env}}</p>`

# Test rate limit metadata in context
GET /test-context-ratelimit
  |> rateLimit: `keyTemplate: context-test, limit: 100, window: 1m`
  |> jq: `{
    allowed: $context.rate_limit.allowed,
    has_limit: ($context.rate_limit.limit != null),
    has_remaining: ($context.rate_limit.remaining != null)
  }`

# Test context with feature flags
GET /test-context-flags
  |> jq: `{
    flag_count: ($context.flags | length)
  }`

describe "Context Injection"

  it "injects context into JQ middleware"
    when calling GET /test-context-jq
    then status is 200
    and output `.has_context` equals true
    and output `.has_flags` equals true
    and output `.message` equals "JQ context works"

  it "injects context into Lua middleware"
    when calling GET /test-context-lua
    then status is 200
    and output `.has_context` equals true
    and output `.has_flags` equals true
    and output `.message` equals "Lua context works"

  it "injects context into Handlebars middleware"
    when calling GET /test-context-handlebars
    then status is 200
    and output contains "Hello WebPipe!"

  it "exposes rate limit metadata in context"
    when calling GET /test-context-ratelimit
    then status is 200
    and output `.allowed` equals true
    and output `.has_limit` equals true
    and output `.has_remaining` equals true

## Dispatch Feature Demo (v2.1+)
# Demonstrates the new dispatch syntax as an alternative to @tag filtering on steps

# Equivalent using dispatch syntax - cleaner for branching logic
GET /feature-test-dispatch
  |> dispatch
    case @flag(experimental-feature):
      |> jq: `{ message: "Experimental feature enabled!" }`
    default:
      |> jq: `{ message: "Standard feature (no flag required)" }`

# More complex example: environment-based dispatch
GET /env-dispatch
  |> dispatch
    case @env(production):
      |> jq: `{ env: "production", debug: false, caching: true }`
    case @env(staging):
      |> jq: `{ env: "staging", debug: true, caching: true }`
    case @env(development):
      |> jq: `{ env: "development", debug: true, caching: false }`
    default:
      |> jq: `{ env: "unknown", debug: false, caching: false }`

# Dispatch with negated tags
GET /non-production-dispatch
  |> dispatch
    case @!env(production):
      |> jq: `{
        message: "Non-production environment",
        debugTools: true,
        mockData: true
      }`
    default:
      |> jq: `{
        message: "Production environment",
        debugTools: false,
        mockData: false
      }`

# Dispatch with multi-step pipelines
GET /multi-step-dispatch
  |> dispatch
    case @flag(experimental):
      |> jq: `{ step: 1, version: "experimental" }`
      |> jq: `. + { step: 2, features: ["ai", "realtime"] }`
      |> jq: `. + { step: 3, complete: true }`
    case @flag(beta):
      |> jq: `{ step: 1, version: "beta" }`
      |> jq: `. + { step: 2, features: ["analytics"] }`
    default:
      |> jq: `{ step: 1, version: "stable", features: [] }`

describe "Dispatch Feature"
  it "routes based on feature flags"
    when calling GET /feature-test-dispatch
    then status is 200
    and output `.message` contains "feature"

  it "handles environment-based routing to default"
    when calling GET /env-dispatch
    then status is 200

  it "handles negated tags in dispatch"
    when calling GET /non-production-dispatch
    then status is 200
    and output `.message` contains "environment"

  it "executes multi-step pipelines in dispatch branches"
    when calling GET /multi-step-dispatch
    then status is 200
    and output `.step` equals 1
    and output `.version` equals "stable"
