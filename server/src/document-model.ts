import {\n  parseProgramWithDiagnostics,\n  Program,\n  Pipeline,\n  When,\n  ParseDiagnostic\n} from 'webpipe-js';\n\nexport interface RouteSegment {\n  kind: 'static' | 'param';\n  text: string;\n}\n\nexport interface RouteIndex {\n  method: string;\n  path: string;\n  segments: RouteSegment[];\n}\n\nexport interface StepInvocation {\n  kind: 'Regular';\n  stepType: string;\n  config: string;\n  configType: 'backtick' | 'quoted' | 'identifier';\n  stepNameStart?: number;\n  stepNameEnd?: number;\n  configStart?: number;\n  configEnd?: number;\n}\n\nexport interface ResultBranchInvocation {\n  kind: 'ResultBranch';\n  branchType: string; // Ok | Default | Custom:<name>\n  statusCode: number;\n}\n\nexport interface PipelineReference {\n  name: string;\n}\n\nexport interface VariableReference {\n  varType: string;\n  name: string;\n}\n\nexport interface RouteReference {\n  method: string;\n  path: string;\n}\n\nexport interface TestAssertion {\n  field: string;\n  comparison: string;\n  value: string;\n  jqExpr?: string;\n}\n\nexport interface DocumentModel {\n  text: string;\n  program: Program;\n  parserDiagnostics: ParseDiagnostic[];\n\n  // Declarations\n  variablesByType: Map<string, Set<string>>;\n  variableDeclarations: Map<string, { start?: number; length?: number }>;\n  pipelineNames: Set<string>;\n  pipelineDeclarations: Map<string, { start?: number; length?: number }>;\n  routes: RouteIndex[];\n\n  // Usages\n  stepInvocations: StepInvocation[];\n  resultBranchInvocations: ResultBranchInvocation[];\n  pipelineReferences: PipelineReference[];\n  variableReferences: VariableReference[];\n  routeReferences: RouteReference[];\n  testAssertions: TestAssertion[];\n}\n\nexport function buildDocumentModel(text: string): DocumentModel {\n  const { program, diagnostics } = parseProgramWithDiagnostics(text);\n\n  const variablesByType = new Map<string, Set<string>>();\n  const variableDeclarations = new Map<string, { start?: number; length?: number }>();\n  for (const v of program.variables) {\n    if (!variablesByType.has(v.varType)) variablesByType.set(v.varType, new Set());\n    variablesByType.get(v.varType)!.add(v.name);\n    variableDeclarations.set(keyVar(v.varType, v.name), {});\n  }\n\n  const pipelineNames = new Set<string>();\n  const pipelineDeclarations = new Map<string, { start?: number; length?: number }>();\n  for (const p of program.pipelines) {\n    pipelineNames.add(p.name);\n    pipelineDeclarations.set(p.name, {});\n  }\n\n  const routes: RouteIndex[] = program.routes.map(r => ({\n    method: r.method,\n    path: r.path,\n    segments: segmentRoutePath(r.path)\n  }));\n\n  // Collect steps & nested structures\n  const stepInvocations: StepInvocation[] = [];\n  const resultBranchInvocations: ResultBranchInvocation[] = [];\n  const pipelineReferences: PipelineReference[] = [];\n  const variableReferences: VariableReference[] = [];\n  const routeReferences: RouteReference[] = [];\n  const testAssertions: TestAssertion[] = [];\n\n  // Pipelines\n  for (const np of program.pipelines) {\n    collectPipeline(np.pipeline, stepInvocations, resultBranchInvocations, pipelineReferences, variableReferences);\n  }\n\n  // Routes -> pipeline refs (named or inline) + route declarations already captured\n  for (const r of program.routes) {\n    if (r.pipeline.kind === 'Named') {\n      pipelineReferences.push({ name: r.pipeline.name });\n    } else {\n      collectPipeline(r.pipeline.pipeline, stepInvocations, resultBranchInvocations, pipelineReferences, variableReferences);\n    }\n  }\n\n  // Tests\n  for (const d of program.describes) {\n    for (const t of d.tests) {\n      collectWhen(t.when, pipelineReferences, variableReferences, routeReferences);\n      for (const c of t.conditions) {\n        testAssertions.push({\n          field: c.field,\n          comparison: c.comparison,\n          value: c.value,\n          jqExpr: c.jqExpr\n        });\n      }\n    }\n  }\n\n  return {\n    text,\n    program,\n    parserDiagnostics: diagnostics,\n    variablesByType,\n    variableDeclarations,\n    pipelineNames,\n    pipelineDeclarations,\n    routes,\n    stepInvocations,\n    resultBranchInvocations,\n    pipelineReferences,\n    variableReferences,\n    routeReferences,\n    testAssertions\n  };\n}\n\nfunction keyVar(varType: string, name: string) {\n  return `${varType}::${name}`;\n}\n\nfunction segmentRoutePath(path: string): RouteSegment[] {\n  if (!path.startsWith('/')) return [];\n  return path.split('/').filter((s, i) => !(i === 0 && s === '')).map(seg => {\n    if (seg.startsWith(':')) {\n      return { kind: 'param', text: seg.slice(1) } as RouteSegment;\n    }\n    return { kind: 'static', text: seg } as RouteSegment;\n  });\n}\n\nimport type { Pipeline as PLine } from 'webpipe-js';\nfunction collectPipeline(\n  pipeline: PLine,\n  stepInvs: StepInvocation[],\n  resultInvs: ResultBranchInvocation[],\n  pipeRefs: PipelineReference[],\n  varRefs: VariableReference[]\n) {\n  for (const step of pipeline.steps) {\n    if (step.kind === 'Regular') {\n      stepInvs.push({\n        kind: 'Regular',\n        stepType: step.name,\n        config: step.config,\n        configType: step.configType\n      });\n      if (step.configType === 'identifier') {\n        varRefs.push({ varType: step.name, name: step.config });\n      }\n    } else if (step.kind === 'Result') {\n      for (const br of step.branches) {\n        let branchType: string;\n        if (br.branchType.kind === 'Ok') branchType = 'Ok';\n        else if (br.branchType.kind === 'Default') branchType = 'Default';\n        else branchType = `Custom:${br.branchType.name}`;\n        resultInvs.push({\n          kind: 'ResultBranch',\n          branchType,\n          statusCode: br.statusCode\n        });\n        collectPipeline(br.pipeline, stepInvs, resultInvs, pipeRefs, varRefs);\n      }\n    }\n  }\n}\n\nimport type { When } from 'webpipe-js';\nfunction collectWhen(\n  when: When,\n  pipeRefs: PipelineReference[],\n  varRefs: VariableReference[],\n  routeRefs: RouteReference[]\n) {\n  switch (when.kind) {\n    case 'ExecutingPipeline':\n      pipeRefs.push({ name: when.name });\n      break;\n    case 'ExecutingVariable':\n      varRefs.push({ varType: when.varType, name: when.name });\n      break;\n    case 'CallingRoute':\n      routeRefs.push({ method: when.method, path: when.path });\n      break;\n  }\n}