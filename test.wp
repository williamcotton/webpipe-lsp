# Test App

## Config
config pg {
  host: $WP_PG_HOST || "localhost"
  port: $WP_PG_PORT || "5432"
  database: $WP_PG_DATABASE || "express-test"
  user: $WP_PG_USER || "postgres"
  password: $WP_PG_PASSWORD || "postgres"
  ssl: false
  initialPoolSize: 10
  maxPoolSize: 20
}

config auth {
  sessionTtl: 604800
  cookieName: "wp_session"
  cookieSecure: false
  cookieHttpOnly: true
  cookieSameSite: "Lax"
  cookiePath: "/"
}

## Tests

pipeline getTeams =
  |> jq: `{ sqlParams: [.params.id | tostring] }`
  |> pg: `SELECT * FROM teams WHERE id = $1`

GET /hello
  |> jq: `{ hello: "world" }`

GET /page/:id
  |> pipeline: getTeams
  |> jq: `{ team: .data.rows[0] }`

pg teamsQuery = `SELECT * FROM teams`

GET /teams
  |> jq: `{ sqlParams: [] }`
  |> pg: teamsQuery

# Testing standalone variables
describe "teamsQuery variable"
  with mock pg.teamsQuery returning `{
    "rows": [
      { "id": "1", "name": "Platform", "member_count": 8 },
      { "id": "2", "name": "Growth", "member_count": 12 },
      { "id": "3", "name": "Security", "member_count": 5 }
    ]
  }`

  it "returns all teams"
    when executing variable pg teamsQuery
    with input `{ "sqlParams": [] }`
    then output equals `{
      "rows": [
        { "id": "1", "name": "Platform", "member_count": 8 },
        { "id": "2", "name": "Growth", "member_count": 12 },
        { "id": "3", "name": "Security", "member_count": 5 }
      ]
    }`

# Testing a pipeline directly
describe "getTeams pipeline"
  with mock pg returning `{
    "rows": [{ "id": "2", "name": "Growth", "created_at": "2024-01-20" }]
  }`

  it "transforms params and queries database"
    when executing pipeline getTeams
    with input `{ "params": { "id": "2" } }`
    then output equals `{
      "rows": [{ "id": "2", "name": "Growth", "created_at": "2024-01-20" }]
    }`

  it "handles string id parameter"
    when executing pipeline getTeams
    with input `{ "params": { "id": "42" } }`
    and mock pg returning `{ "rows": [{ "id": "42", "name": "Marketing" }] }`
    then output equals `{
      "rows": [{ "id": "42", "name": "Marketing" }]
    }`

describe "test calling route"
  it "calls the route"
    when calling GET /hello
    then status is 200
    and output equals `{
      "hello": "world"
    }`

GET /test
  |> jq: `.`

GET /test2
  |> lua: `return request`

GET /test3
  |> jq: `{message: "Hello World", status: "success"}`
  |> result
    ok(200):
      |> jq: `{
        success: true,
        data: .message,
        timestamp: now
      }`
    default(500):
      |> jq: `{
        error: "Something went wrong",
        timestamp: now
      }`

GET /test4
  |> jq: `{
    errors: [
      {
        type: "validationError",
        field: "email",
        message: "Email is required",
        code: "FIELD_REQUIRED"
      }
    ]
  }`
  |> result
    ok(200):
      |> jq: `{success: true}`
    validationError(400):
      |> jq: `{
        error: "Validation failed",
        field: .errors[0].field,
        message: .errors[0].message,
        code: .errors[0].code
      }`
    default(500):
      |> jq: `{error: "Internal server error"}`

GET /test5
  |> jq: `{
    errors: [
      {
        type: "authRequired",
        header: "Authorization",
        expected: "Bearer <token>",
        provided: null
      }
    ]
  }`
  |> result
    ok(200):
      |> jq: `{success: true, data: .result}`
    authRequired(401):
      |> jq: `{
        error: "Authentication required",
        header: .errors[0].header,
        expected: .errors[0].expected,
        provided: .errors[0].provided
      }`
    default(500):
      |> jq: `{error: "Internal server error"}`

GET /test6
  |> jq: `{
    errors: [
      {
        type: "unknownError",
        message: "This is a custom error type not handled explicitly"
      }
    ]
  }`
  |> result
    ok(200):
      |> jq: `{success: true}`
    validationError(400):
      |> jq: `{error: "Validation error"}`
    default(500):
      |> jq: `{
        error: "Unhandled error occurred",
        type: .errors[0].type,
        message: .errors[0].message
      }`

GET /test7
  |> lua: `
    -- Test executeSql function in Lua
    local result, err = executeSql("SELECT * FROM teams LIMIT 5")
    
    if err then
      return {
        error = "Database error: " .. err,
        sql = "SELECT * FROM teams LIMIT 5"
      }
    end
    
    return {
      message = "Lua executeSql test successful",
      sql = "SELECT * FROM teams LIMIT 5",
      data = result,
      luaVersion = _VERSION
    }
  `


GET /test-sql-error
  |> jq: `{ sqlParams: [] }`
  |> pg: `SELECT * FROM nonexistent_table`
  |> result
    ok(200):
      |> jq: `{success: true, data: .data}`
    sqlError(500):
      |> jq: `{
        error: "Database error",
        sqlstate: .errors[0].sqlstate,
        message: .errors[0].message,
        query: .errors[0].query
      }`
    default(500):
      |> jq: `{error: "Internal server error"}`

POST /users
  |> jq: `{
    method: .method,
    name: .body.name,
    email: .body.email,
    action: "create"
  }`

PUT /users/:id
  |> jq: `{
    method: .method,
    id: (.params.id | tonumber),
    name: .body.name,
    email: .body.email,
    action: "update"
  }`

PATCH /users/:id
  |> jq: `{
    method: .method,
    id: (.params.id | tonumber),
    body: .body,
    action: "partial_update"
  }`

POST /test-body
  |> jq: `{
    method: .method,
    body: .body,
    hasBody: (.body != null)
  }`

PUT /test-body
  |> jq: `{
    method: .method,
    body: .body,
    hasBody: (.body != null)
  }`

PATCH /test-body
  |> jq: `{
    method: .method,
    body: .body,
    hasBody: (.body != null)
  }`

GET /hello-mustache
  |> jq: `{ name: "World", message: "Hello from mustache!" }`
  |> mustache: `
    <html>
      <head>
        <title>{{message}}</title>
      </head>
      <body>
        <h1>{{message}}</h1>
        <p>Hello, {{name}}!</p>
      </body>
    </html>
  `

GET /mustache-error-test
  |> jq: `{ invalid: "data" }`
  |> mustache: `{{syntax_error`

mustache cardPartial = `
  <div class="card">
    <h3>{{title}}</h3>
    <p>{{description}}</p>
  </div>
`

mustache headerPartial = `
  <header>
    <h1>{{siteName}}</h1>
    <nav>{{>navPartial}}</nav>
  </header>
`

mustache navPartial = `
  <ul>
    <li><a href="/">Home</a></li>
    <li><a href="/about">About</a></li>
  </ul>
`

mustache highlightJsScript = """
<script>
// Register WebPipe language definition
hljs.registerLanguage('webpipe', function(hljs) {
  return {
    name: 'WebPipe',
    case_insensitive: false,
    contains: [
      // Comments
      hljs.HASH_COMMENT_MODE,

      // HTTP Methods
      {
        scope: 'keyword',
        match: '\\b(GET|POST|PUT|PATCH|DELETE|HEAD|OPTIONS)\\b'
      },

      // Config / pipeline keywords
      {
        scope: 'keyword',
        match: '\\b(config|pipeline)\\b'
      },

      // ────────────────────────────────────────────────
      //  NEW: middleware keyword in *variable assignment*
      //       e.g.  pg pageQuery = `…`
      // ────────────────────────────────────────────────
      {
        scope: 'keyword',
        match: '^\\s*[a-zA-Z_][a-zA-Z0-9_]*(?=\\s+[a-zA-Z_][a-zA-Z0-9_]*\\s*=)'
      },

      // Pipeline operator
      {
        scope: 'operator',
        match: '\\|>'
      },

      // Middleware functions in pipelines (word before colon)
      {
        scope: 'keyword',
        match: '\\b[a-zA-Z_][a-zA-Z0-9_]*(?=\\s*:)'
      },

      // Route paths
      {
        scope: 'string',
        match: '/[^\\s]*',
        contains: [
          {
            scope: 'variable',
            match: ':[a-zA-Z_][a-zA-Z0-9_]*'
          }
        ]
      },

      // Lua embedded content
      {
        begin: '\\blua:\\s*`',
        end: '`',
        subLanguage: 'lua',
        contains: [
          {
            scope: 'variable',
            match: 'request\\.[a-zA-Z_][a-zA-Z0-9_]*'
          }
        ]
      },

      // JQ embedded content
      {
        begin: '\\bjq:\\s*`',
        end: '`',
        subLanguage: 'json',
        contains: [
          {
            scope: 'variable',
            match: '\\.[a-zA-Z_][a-zA-Z0-9_]*'
          }
        ]
      },

      // SQL embedded content
      {
        begin: '\\bpg:\\s*`',
        end: '`',
        subLanguage: 'sql'
      },

      // Generic back‑tick strings
      {
        scope: 'string',
        begin: '`',
        end: '`',
        contains: [
          {
            scope: 'variable',
            match: '\\.[a-zA-Z_][a-zA-Z0-9_]*'
          },
          hljs.QUOTE_STRING_MODE
        ]
      },

      // Regular quoted strings
      hljs.QUOTE_STRING_MODE,

      // Numbers
      hljs.C_NUMBER_MODE,

      // Environment variables
      {
        scope: 'variable',
        match: '\\$[a-zA-Z_][a-zA-Z0-9_]*'
      },

      // Boolean literals
      {
        scope: 'literal',
        match: '\\b(true|false)\\b'
      },

      // BDD test keywords with quoted strings
      {
        begin: '\\b(describe|it)\\s+',
        beginScope: 'keyword',
        end: '$',
        contains: [
          {
            scope: 'string',
            match: '"[^"]*"'
          }
        ]
      },

      // Other BDD keywords
      {
        scope: 'keyword',
        match: '\\b(with|when|then|and|executing|calling|input|output|equals|status|mock|returning)\\b'
      }
    ]
  };
});
hljs.highlightAll();
</script>
"""

GET /test-partials
  |> jq: `{ 
    title: "Welcome", 
    description: "This is a test card",
    siteName: "My Website"
  }`
  |> mustache: `
    <html>
      <head>
        <title>{{siteName}}</title>
      </head>
      <body>
        {{>headerPartial}}
        <main>
          {{>cardPartial}}
        </main>
      </body>
    </html>
  `

GET /test-missing-partial
  |> jq: `{ title: "Test" }`
  |> mustache: `
    <html>
      <body>
        {{>nonexistentPartial}}
      </body>
    </html>
  `

GET /test-sql-error-mustache
  |> jq: `{ sqlParams: [] }`
  |> pg: `SELECT * FROM nonexistent_table`
  |> result
    ok(200):
      |> jq: `{success: true, data: .data}`
    sqlError(500):
      |> jq: `{
        error: "Database error",
        sqlstate: .errors[0].sqlstate,
        message: .errors[0].message,
        query: .errors[0].query
      }`
      |> mustache: `{{error}}`
    default(500):
      |> jq: `{error: "Internal server error"}`
      |> mustache: `{{error}}`

GET /cookies
  |> jq: `{
    message: "Cookie test response",
    cookies: .cookies,
    setCookies: [
      "sessionId=abc123; HttpOnly; Secure; Max-Age=3600",
      "userId=john; Max-Age=86400",
      "theme=dark; Path=/"
    ]
  }`

GET /auth/status
  |> auth: "optional"
  |> jq: `{
    authenticated: (.user != null),
    user: .user,
    message: if .user then "User is authenticated" else "User is not authenticated" end
  }`

GET /debug/users
  |> jq: `{ sqlParams: [] }`
  |> pg: `SELECT id, login, email, type, status, created_at FROM users LIMIT 5`
  |> jq: `{
    message: "Users in database",
    users: .data.rows,
    count: (.data.rows | length)
  }`

GET /debug/test-user
  |> jq: `{ sqlParams: ["admin"] }`
  |> pg: `SELECT id, login, password_hash, email, type, status FROM users WHERE login = $1 AND status = 'active'`
  |> jq: `{
    message: "Test user lookup for 'admin'",
    found: (.data.rows | length > 0),
    user: if (.data.rows | length > 0) then .data.rows[0] else null end
  }`

GET /debug/users-schema
  |> jq: `{ sqlParams: [] }`
  |> pg: `SELECT column_name, data_type, is_nullable, column_default FROM information_schema.columns WHERE table_name = 'users' ORDER BY ordinal_position`
  |> jq: `{
    message: "Users table schema",
    columns: .data.rows
  }`

POST /debug/test-hash
  |> auth: "register"
  |> jq: `{
    message: "Test hash generation (this will fail but show us what's happening)",
    body: .body,
    errors: .errors
  }`

config cache {
  enabled: true
  defaultTtl: 60
  maxCacheSize: 10485760
}

GET /cache-test
  |> cache: `
    ttl: 10
    enabled: true
  `
  |> jq: `{
    message: "Hello from cache test!",
    timestamp: now,
    random: (now % 1000)
  }`

GET /no-cache-test  
  |> jq: `{
    message: "No cache here",
    timestamp: now,
    random: (now % 1000)
  }`

GET /slow-cached-test
  |> cache: `
    ttl: 30
    enabled: true
  `
  |> jq: `{ sqlParams: [] }`
  |> pg: `SELECT pg_sleep(0.25), 'Slow database operation completed!' as message, now() as timestamp`
  |> jq: `{
    message: .data.rows[0].message,
    timestamp: .data.rows[0].timestamp,
    cached: true,
    note: "This query sleeps for 250ms - should be fast on cache hit!"
  }`

GET /slow-uncached-test
  |> jq: `{ sqlParams: [] }`
  |> pg: `SELECT pg_sleep(0.25), 'Slow database operation completed!' as message, now() as timestamp`
  |> jq: `{
    message: .data.rows[0].message,
    timestamp: .data.rows[0].timestamp,
    cached: false,
    note: "This query sleeps for 250ms - always slow!"
  }`

GET /very-slow-cached-test
  |> cache: `
    ttl: 60
    enabled: true
  `
  |> jq: `{ sqlParams: [] }`
  |> pg: `SELECT pg_sleep(1.0), 'Very slow database operation completed!' as message, now() as timestamp, random() as random_value`
  |> jq: `{
    message: .data.rows[0].message,
    timestamp: .data.rows[0].timestamp,
    random_value: .data.rows[0].random_value,
    cached: true,
    note: "This query sleeps for 1 second - cache makes a huge difference!"
  }`

GET /user/:id/profile
  |> cache: `
    keyTemplate: user-profile-{params.id}
    ttl: 30
    enabled: true
  `
  |> jq: `{ sqlParams: [.params.id] }`
  |> pg: `SELECT pg_sleep(0.5), $1 as user_id, 'User profile data' as profile_type, now() as fetched_at`
  |> jq: `{
    user_id: .data.rows[0].user_id,
    profile_type: .data.rows[0].profile_type,
    fetched_at: .data.rows[0].fetched_at,
    cache_key_used: "user-profile-" + (.originalRequest.params.id | tostring),
    note: "Cache key includes user ID from URL parameter"
  }`

GET /api/search
  |> log: `level: debug, includeBody: true, includeHeaders: true`
  |> cache: `
    keyTemplate: search-{query.q}-{query.category}
    ttl: 15
    enabled: true
  `
  |> jq: `{ 
    sqlParams: [.query.q // "default", .query.category // "all"],
    search_term: .query.q,
    search_category: .query.category
  }`
  |> pg: `SELECT pg_sleep(0.3), $1 as term, $2 as category, 'Search results' as result_type, now() as searched_at`
  |> jq: `{
    search_term: .data.rows[0].term,
    category: .data.rows[0].category,
    result_type: .data.rows[0].result_type,
    searched_at: .data.rows[0].searched_at,
    cache_key_used: "search-" + (.originalRequest.query.q | tostring) + "-" + (.originalRequest.query.category | tostring),
    note: "Cache key varies by search term and category query parameters"
  }`

config log {
  enabled: true
  format: "json"
  level: "debug"
  includeBody: false
  includeHeaders: true
  maxBodySize: 1024
  timestamp: true
}

  
GET /api/users/:id
  |> log: `level: debug, includeBody: true, includeHeaders: true`
  |> pg: `SELECT * FROM users WHERE id = $1`

## Todos App

mustache baseLayout = `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{{$title}}Default Title{{/title}}</title>
  <script src="https://unpkg.com/htmx.org@1.9.10"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  {{$headExtras}}{{/headExtras}}
</head>
<body class="bg-gray-100 font-sans">
  {{$content}}Default content{{/content}}
  {{$footerScripts}}{{/footerScripts}}
</body>
</html>
`

mustache authLayout = `
{{<baseLayout}}
  {{$content}}
    <div class="max-w-4xl mx-auto p-6">
      <div class="bg-white p-6 rounded-lg shadow-md">
        {{$authHeader}}
          <div class="flex justify-between items-center border-b-2 border-blue-500 pb-3 mb-6">
            <h1 class="text-3xl font-bold text-gray-800">{{$pageTitle}}Page Title{{/pageTitle}}</h1>
            <div class="flex items-center space-x-4">
              <span class="text-gray-600">Welcome, {{user.login}}!</span>
              <button hx-post="/logout" hx-swap="none" hx-on::after-request="window.location.href='/login-page'" class="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors">Logout</button>
            </div>
          </div>
        {{/authHeader}}
        {{$pageContent}}Page content goes here{{/pageContent}}
      </div>
    </div>
  {{/content}}
{{/baseLayout}}
`
POST /login
  |> validate: `{
    login: string(3..50),
    password: string(6..100)
  }`
  |> auth: "login"
  |> result
    ok(200):
      |> jq: `{
        success: true,
        message: "Login successful",
        user: {
          id: .user.id | tostring,
          login: .user.login,
          email: .user.email,
          type: .user.type
        }
      }`
    validationError(400):
      |> jq: `{
        success: false,
        error: "Validation failed",
        field: .errors[0].context,
        message: .errors[0].message
      }`
      |> mustache: `
        <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4" role="alert">
          <strong class="font-bold">Validation Error:</strong>
          <span class="block sm:inline">{{message}}</span>
        </div>
      `
    authError(401):
      |> jq: `{
        success: false,
        error: "Login failed",
        message: .errors[0].message,
        context: .errors[0].context,
        fullError: .errors[0]
      }`
      |> mustache: `
        <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4" role="alert">
          <strong class="font-bold">Login Failed:</strong>
          <span class="block sm:inline">{{message}}</span>
          {{#context}}<br><small>Context: {{context}}</small>{{/context}}
        </div>
      `

POST /logout
  |> auth: "logout"
  |> result
    ok(200):
      |> jq: `{
        success: true,
        message: "Logged out successfully"
      }`
    authError(401):
      |> jq: `{
        success: false,
        error: "Logout failed",
        message: .errors[0].message
      }`

POST /register
  |> validate: `{
    login: string(3..50),
    email: email,
    password: string(8..100)
  }`
  |> auth: "register"
  |> result
    ok(201):
      |> jq: `{
        success: true,
        message: "Registration successful"
      }`
      |> mustache: `
        <div class="bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded mb-4" role="alert">
          <strong class="font-bold">Success!</strong>
          <span class="block sm:inline">Account created successfully. Redirecting to login...</span>
        </div>
      `
    validationError(400):
      |> jq: `{
        success: false,
        error: "Validation failed",
        field: .errors[0].context,
        message: .errors[0].message
      }`
      |> mustache: `
        <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4" role="alert">
          <strong class="font-bold">Validation Error:</strong>
          <span class="block sm:inline">{{message}}</span>
        </div>
      `
    authError(409):
      |> jq: `{
        success: false,
        error: "Registration failed",
        message: .errors[0].message
      }`
      |> mustache: `
        <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4" role="alert">
          <strong class="font-bold">Registration Failed:</strong>
          <span class="block sm:inline">{{message}}</span>
        </div>
      `

GET /login-page
  |> jq: `{
    pageTitle: "Login - Todo App",
    message: "Please log in to access your todos"
  }`
  |> mustache: `
  {{<baseLayout}}
    {{$content}}
    <body class="bg-gray-100 font-sans">
      <div class="max-w-md mx-auto mt-20 p-6">
        <div class="bg-white p-8 rounded-lg shadow-md">
          <div class="text-center mb-8">
            <h1 class="text-3xl font-bold text-gray-800 mb-2">Welcome Back</h1>
            <p class="text-gray-600">{{message}}</p>
          </div>
          
          <div id="login-response" class="mb-4"></div>
          
          <form hx-post="/login" hx-target="#login-response" hx-swap="innerHTML" class="space-y-4">
            <div>
              <label for="login" class="block text-sm font-medium text-gray-700 mb-1">Username</label>
              <input type="text" id="login" name="login" required class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" placeholder="Enter your username">
            </div>
            <div>
              <label for="password" class="block text-sm font-medium text-gray-700 mb-1">Password</label>
              <input type="password" id="password" name="password" required class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" placeholder="Enter your password">
            </div>
            <button type="submit" class="w-full bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors">
              Sign In
            </button>
          </form>
          
          <div class="mt-6 text-center">
            <p class="text-sm text-gray-600">
              Don't have an account? 
              <a href="/register-page" class="text-blue-500 hover:text-blue-600 font-medium">Sign up</a>
            </p>
          </div>
          
          <div class="mt-4 text-center">
            <a href="/hello" class="text-sm text-gray-500 hover:text-gray-700">← Back to Home</a>
          </div>
        </div>
      </div>
      
      <script>
        // Redirect to todos on successful login
        document.body.addEventListener('htmx:afterRequest', function(event) {
          if (event.detail.xhr.status === 200 && event.detail.target.id === 'login-response') {
            try {
              const response = JSON.parse(event.detail.xhr.responseText);
              if (response.success) {
                window.location.href = '/todos';
              }
            } catch (e) {
              // If not JSON, might be an error message
            }
          }
        });
      </script>
    {{/content}}
  {{/baseLayout}}
  `

GET /register-page
  |> jq: `{
    pageTitle: "Register - Todo App",
    message: "Create your account to get started"
  }`
  |> mustache: `
  {{<baseLayout}}
    {{$content}}
      <div class="max-w-md mx-auto mt-20 p-6">
        <div class="bg-white p-8 rounded-lg shadow-md">
          <div class="text-center mb-8">
            <h1 class="text-3xl font-bold text-gray-800 mb-2">Create Account</h1>
            <p class="text-gray-600">{{message}}</p>
          </div>
          
          <div id="register-response" class="mb-4"></div>
          
          <form hx-post="/register" hx-target="#register-response" hx-swap="innerHTML" class="space-y-4">
            <div>
              <label for="login" class="block text-sm font-medium text-gray-700 mb-1">Username</label>
              <input type="text" id="login" name="login" required class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" placeholder="Choose a username (3-50 chars)">
            </div>
            <div>
              <label for="email" class="block text-sm font-medium text-gray-700 mb-1">Email</label>
              <input type="email" id="email" name="email" required class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" placeholder="Enter your email">
            </div>
            <div>
              <label for="password" class="block text-sm font-medium text-gray-700 mb-1">Password</label>
              <input type="password" id="password" name="password" required class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" placeholder="Choose a password (8+ chars)">
            </div>
            <button type="submit" class="w-full bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors">
              Create Account
            </button>
          </form>
          
          <div class="mt-6 text-center">
            <p class="text-sm text-gray-600">
              Already have an account? 
              <a href="/login-page" class="text-blue-500 hover:text-blue-600 font-medium">Sign in</a>
            </p>
          </div>
          
          <div class="mt-4 text-center">
            <a href="/hello" class="text-sm text-gray-500 hover:text-gray-700">← Back to Home</a>
          </div>
        </div>
      </div>
      
      <script>
        // Redirect to login on successful registration
        document.body.addEventListener('htmx:afterRequest', function(event) {
          if (event.detail.xhr.status === 200 && event.detail.target.id === 'register-response') {
            try {
              const response = JSON.parse(event.detail.xhr.responseText);
              if (response.success) {
                window.location.href = '/login-page';
              }
            } catch (e) {
              // If not JSON, might be an error message
            }
          }
        });
      </script>
    {{/content}}
  {{/baseLayout}}
  `

mustache loginRequiredLayout = `
{{<baseLayout}}
  {{$title}}Login Required{{/title}}
  {{$content}}
    <div class="max-w-md mx-auto mt-20 p-6">
      <div class="bg-white p-8 rounded-lg shadow-md text-center">
        <div class="mb-6">
          <svg class="mx-auto h-16 w-16 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"/>
          </svg>
        </div>
        <h1 class="text-2xl font-bold text-gray-800 mb-4">Authentication Required</h1>
        <p class="text-gray-600 mb-6">You need to log in to access your todo list.</p>
        <div class="space-y-3">
          <a href="/login-page" class="block w-full bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors">Go to Login</a>
          <a href="/hello" class="block w-full bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors">Go to Home</a>
        </div>
      </div>
    </div>
  {{/content}}
{{/baseLayout}}
`

mustache errorAlert = `
<div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4 mt-4" role="alert">
  <strong class="font-bold">{{$errorTitle}}Error{{/errorTitle}}:</strong>
  <span class="block sm:inline">{{$errorMessage}}Something went wrong{{/errorMessage}}</span>
</div>
`

GET /todos
  |> auth: "required"
  |> result
    ok(200):
      |> jq: `. + { sqlParams: [.user.id | tostring] }`
      |> pg: `SELECT id, title, completed, created_at, updated_at FROM todos WHERE user_id = $1 ORDER BY created_at DESC`
      |> jq: `. + {
        todos: .data.rows | map(. + {id: (.id | tostring)}),
        pageTitle: "Todo List"
      }`
      |> mustache: `
        {{<authLayout}}
          {{$title}}{{pageTitle}}{{/title}}
          {{$pageTitle}}{{pageTitle}} - {{user.login}}{{/pageTitle}}
          {{$pageContent}}
            <div class="bg-gray-50 p-6 rounded-lg mb-6">
              <h3 class="text-lg font-semibold mb-4">Add New Todo</h3>
              <div id="form-errors"></div>
              <form hx-post="/todos/add" hx-target="#form-response" hx-swap="innerHTML" hx-on::response-error="document.getElementById('form-response').innerHTML = event.detail.xhr.responseText" class="space-y-4">
                <div>
                  <label for="title" class="block text-sm font-medium text-gray-700 mb-1">Title * (3-30 characters)</label>
                  <input type="text" id="title" name="title" required class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                </div>
                <button type="submit" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors">Add Todo</button>
              </form>
              <div id="form-response"></div>
            </div>
            
            <ul id="todo-list" class="space-y-3">
              {{#todos}}
              {{>todoItemPartial}}
              {{/todos}}
              {{^todos}}
              <li class="text-center text-gray-500 italic py-10">
                <p>No todos yet. Add your first todo above!</p>
              </li>
              {{/todos}}
            </ul>
          {{/pageContent}}
        {{/authLayout}}
      `
    authError(401):
      |> mustache: `{{>loginRequiredLayout}}`

POST /todos/add
  |> auth: "required"
  |> result
    ok(200):
      |> validate: `
        title: string(3..30)
      `
      |> jq: `. + { 
        sqlParams: [.body.title, false, .user.id | tostring]
      }`
      |> pg: `INSERT INTO todos (title, completed, user_id) VALUES ($1, $2, $3) RETURNING *`
      |> result
        ok(201):
          |> jq: `(.data.rows[0] | . + {id: (.id | tostring)})`
          |> mustache: `
            <div hx-swap-oob="afterbegin:#todo-list">
              {{>todoItemPartial}}
            </div>
            <input type="text" id="title" name="title" required class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" value="" hx-swap-oob="true">
          `
        validationError(400):
          |> jq: `{
            error: "Validation failed",
            field: .errors[0].field,
            rule: .errors[0].rule,
            message: .errors[0].message
          }`
          |> mustache: `
            {{<errorAlert}}
              {{$errorTitle}}Validation Error{{/errorTitle}}
              {{$errorMessage}}{{message}}{{/errorMessage}}
            {{/errorAlert}}
          `
    authError(401):
      |> mustache: `
        {{<errorAlert}}
          {{$errorTitle}}Authentication Required{{/errorTitle}}
          {{$errorMessage}}Please log in to add todos.{{/errorMessage}}
        {{/errorAlert}}
      `

POST /todos/:id/toggle
  |> auth: "required"
  |> result
    ok(200):
      |> jq: `{ sqlParams: [.params.id, .user.id | tostring], todoId: .params.id }`
      |> pg: `SELECT * FROM todos WHERE id = $1 AND user_id = $2`
      |> jq: `{ 
        sqlParams: [(.data.rows[0].completed | not), .todoId],
        currentTodo: .data.rows[0]
      }`
      |> pg: `UPDATE todos SET completed = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2 RETURNING *`
      |> jq: `(.data.rows[0] | . + {id: (.id | tostring)})`
      |> mustache: `{{>todoItemPartial}}`
    authError(401):
      |> mustache: `
        {{<errorAlert}}
          {{$errorTitle}}Authentication Required{{/errorTitle}}
          {{$errorMessage}}Please log in to modify todos.{{/errorMessage}}
        {{/errorAlert}}
      `

DELETE /todos/:id
  |> auth: "required"
  |> result
    ok(200):
      |> jq: `{ sqlParams: [.params.id, .user.id | tostring] }`
      |> pg: `DELETE FROM todos WHERE id = $1 AND user_id = $2`
      |> mustache: ``
    authError(401):
      |> mustache: `
        {{<errorAlert}}
          {{$errorTitle}}Authentication Required{{/errorTitle}}
          {{$errorMessage}}Please log in to delete todos.{{/errorMessage}}
        {{/errorAlert}}
      `

mustache todoItemPartial = `
  <li class="{{#completed}}bg-green-50 border-l-4 border-green-400{{/completed}}{{^completed}}bg-gray-50 border-l-4 border-blue-400{{/completed}} p-4 rounded-lg flex justify-between items-start">
    <div class="flex-1">
      <div class="{{#completed}}text-gray-500 line-through{{/completed}}{{^completed}}text-gray-800 font-medium{{/completed}}">{{title}}</div>
      <div class="text-sm text-gray-500 mt-1">Created: {{created_at}}</div>
    </div>
    <div class="flex space-x-2 ml-4">
      {{#completed}}
      <button hx-post="/todos/{{id}}/toggle" hx-target="closest li" hx-swap="outerHTML" class="px-3 py-1 text-sm bg-gray-500 hover:bg-gray-600 text-white rounded transition-colors">Mark Incomplete</button>
      {{/completed}}
      {{^completed}}
      <button hx-post="/todos/{{id}}/toggle" hx-target="closest li" hx-swap="outerHTML" class="px-3 py-1 text-sm bg-green-500 hover:bg-green-600 text-white rounded transition-colors">Mark Complete</button>
      {{/completed}}
      <button hx-delete="/todos/{{id}}" hx-target="closest li" hx-swap="outerHTML" hx-confirm="Are you sure you want to delete this todo?" class="px-3 py-1 text-sm bg-red-500 hover:bg-red-600 text-white rounded transition-colors">Delete</button>
    </div>
  </li>
`

## Test routes for new resultName functionality

# Test explicit resultName functionality
GET /test/named-query/:id
  |> jq: `{ resultName: "userProfile" }`
  |> pg: `SELECT 1 as id, 'Test User' as name, 'test@example.com' as email`
  |> jq: `{ user: .data.userProfile }`

# Test multiple named results
GET /test/multiple/:id
  |> jq: `{ resultName: "userInfo" }`
  |> pg: `SELECT 1 as id, 'Test User' as name`
  |> jq: `{ resultName: "userTeams" }`
  |> pg: `SELECT 1 as id, 'Engineering' as name UNION SELECT 2 as id, 'Product' as name`
  |> jq: `{ 
      profile: .data.userInfo,
      teams: .data.userTeams
    }`

# Test auto-naming with variables (should now use variable name as result key)
pg getUserQuery = `SELECT 1 as id, 'Auto Named User' as name`
pg getTeamsQuery = `SELECT 1 as id, 'Auto Team' as name`

GET /test/auto-naming/:id
  |> pg: getUserQuery
  |> pg: getTeamsQuery
  |> jq: `{ 
      user: .data.getUserQuery,
      teams: .data.getTeamsQuery,
      hasUserData: (.data.getUserQuery != null),
      hasTeamsData: (.data.getTeamsQuery != null)
    }`

# Test that legacy behavior is preserved (no resultName, no variable)
GET /test/legacy/:id
  |> pg: `SELECT 1 as id, 'Legacy User' as name`

# Test getEnv function

GET /test-get-env
  |> lua: `
    local homeDir = getEnv("HOME")
    local nonexistent = getEnv("NONEXISTENT_VAR")
    local withDefault = getEnv("NONEXISTENT_VAR", "default_value")
    local path = getEnv("PATH")
    local dotenvVar = getEnv("TEST_DOTENV_VAR")
    local contentfulSpace = getEnv("CONTENTFUL_SPACE")
    local contentfulToken = getEnv("CONTENTFUL_ACCESS_TOKEN")
    
    return {
      message = "getEnv function test including .env file support",
      home = homeDir,
      nonexistent = nonexistent,
      withDefault = withDefault,
      hasPath = (path ~= nil),
      pathLength = path and string.len(path) or 0,
      dotenvVar = dotenvVar,
      hasContentfulSpace = (contentfulSpace ~= nil),
      hasContentfulToken = (contentfulToken ~= nil)
    }
  `

# Test Fetch Middleware

## Basic GET request
GET /test-fetch
  |> fetch: `https://api.github.com/zen`

## GET with fetchUrl override
GET /test-fetch-override
  |> jq: `{ fetchUrl: "https://api.github.com/zen" }`
  |> fetch: `https://example.com`

## POST with body
GET /test-fetch-post
  |> jq: `{
    fetchMethod: "POST",
    fetchBody: { name: "test", value: 123 },
    fetchHeaders: { "Content-Type": "application/json" }
  }`
  |> fetch: `https://api.github.com/zen`

## Named result
GET /test-fetch-named
  |> jq: `{ resultName: "apiCall" }`
  |> fetch: `https://api.github.com/zen`
  |> jq: `{ 
    response: .data.apiCall.response,
    status: .data.apiCall.status,
    success: (.data.apiCall.status == 200)
  }`

## Test error handling
GET /test-fetch-error
  |> fetch: `https://nonexistent-domain-12345.com`

## Test timeout (if httpbin is slow)
GET /test-fetch-timeout
  |> jq: `{ fetchTimeout: 1 }`
  |> fetch: `https://httpbin.org/delay/5`

# Contentful Integration (Phase 2)

## All blog articles (matching F# allArticles function)
GET /contentful/articles
  |> lua: `
    local spaceId = getEnv("CONTENTFUL_SPACE")
    local token = getEnv("CONTENTFUL_ACCESS_TOKEN")
    
    if not spaceId or not token then
      return {
        errors = {{
          type = "configError",
          message = "Missing Contentful configuration: CONTENTFUL_SPACE and CONTENTFUL_ACCESS_TOKEN required"
        }}
      }
    end
    
    return {
      fetchUrl = "https://cdn.contentful.com/spaces/" .. spaceId .. "/entries?content_type=blogPost&fields.hidden=false&order=-fields.publishedDate",
      fetchHeaders = {
        ["Authorization"] = "Bearer " .. token
      }
    }
  `
  |> fetch: `placeholder`
  |> lua: `
    if request.data and request.data.response then
      local entries = request.data.response.items or {}
      
      -- Trim body content like the F# version (take first 4 content nodes)
      local processedEntries = {}
      for i, entry in ipairs(entries) do
        local fields = entry.fields or {}
        local body = fields.body or {}
        local content = body.content or {}
        
        -- Take only first 4 content nodes for preview
        local trimmedContent = {}
        for j = 1, math.min(4, #content) do
          table.insert(trimmedContent, content[j])
        end
        
        local trimmedBody = {
          content = trimmedContent,
          nodeType = body.nodeType,
          data = body.data
        }
        
        local processedFields = {}
        for k, v in pairs(fields) do
          processedFields[k] = v
        end
        processedFields.body = trimmedBody
        
        table.insert(processedEntries, {
          fields = processedFields,
          sys = entry.sys
        })
      end
      
      return {
        articles = processedEntries,
        total = request.data.response.total or 0,
        message = "Blog articles retrieved successfully"
      }
    else
      return {
        error = "Failed to fetch from Contentful",
        details = request.data
      }
    end
  `
  |> mustache: `
    <html>
      <head>
        <title>William Cotton - Blog Articles</title>
        <style>
          body { font-family: Georgia, serif; max-width: 1000px; margin: 0 auto; padding: 40px 20px; }
          .article-list { display: grid; gap: 30px; }
          .article-preview { border: 1px solid #ddd; padding: 25px; border-radius: 8px; }
          .article-preview h2 { margin-top: 0; }
          .article-meta { color: #666; font-size: 14px; margin: 15px 0; }
          .read-more { color: #007acc; text-decoration: none; font-weight: bold; }
          .read-more:hover { text-decoration: underline; }
          .error { color: red; background: #ffe6e6; padding: 20px; border: 1px solid red; }
        </style>
      </head>
      <body>
        <header>
          <h1>William Cotton - Blog</h1>
          <p>{{total}} articles</p>
        </header>
        
        {{#error}}
          <div class="error">{{error}}</div>
        {{/error}}
        
        <div class="article-list">
          {{#articles}}
            <article class="article-preview">
              <h2><a href="/contentful/article/{{fields.slug}}" class="read-more">{{fields.title}}</a></h2>
              <div class="article-meta">
                Published: {{fields.publishedDate}}<br>
                {{#fields.author}}Author: {{fields.author}}<br>{{/fields.author}}
                {{#fields.tags}}Tags: {{fields.tags}}<br>{{/fields.tags}}
              </div>
              {{#fields.excerpt}}<p>{{fields.excerpt}}</p>{{/fields.excerpt}}
              <a href="/contentful/article/{{fields.slug}}" class="read-more">Read More →</a>
            </article>
          {{/articles}}
          {{^articles}}
            <p>No articles found.</p>
          {{/articles}}
        </div>
      </body>
    </html>
  `

## Blog article by slug (matching F# article function)  
GET /contentful/article/:slug
  |> lua: `
    local spaceId = getEnv("CONTENTFUL_SPACE")
    local token = getEnv("CONTENTFUL_ACCESS_TOKEN")
    local slug = request.params.slug
    
    if not spaceId or not token then
      return {
        errors = {{
          type = "configError", 
          message = "Missing Contentful configuration"
        }}
      }
    end
    
    return {
      fetchUrl = "https://cdn.contentful.com/spaces/" .. spaceId .. "/entries?content_type=blogPost&fields.slug[in]=" .. slug,
      fetchHeaders = {
        ["Authorization"] = "Bearer " .. token
      }
    }
  `
  |> fetch: `placeholder`
  |> lua: `
    if request.data and request.data.response and request.data.response.items then
      local items = request.data.response.items
      if #items > 0 then
        local entry = items[1]
        local fields = entry.fields or {}
        
        -- Enhanced rich text processing for blog posts with full Contentful support
        local function escapeHtml(text)
          if not text then return "" end
          return text:gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;"):gsub("\"", "&quot;"):gsub("'", "&#39;")
        end
        
        local function generateEntryUrl(target)
          if not target or not target.fields then return "#" end
          local contentType = target.sys and target.sys.contentType and target.sys.contentType.sys and target.sys.contentType.sys.id
          local slug = target.fields.slug
          
          if contentType == "blogPost" and slug then
            return "/contentful/article/" .. slug
          elseif contentType == "page" and slug then
            return "/contentful/page/" .. slug
          else
            return "#"
          end
        end
        
        local function renderTextWithMarks(textNode)
          if not textNode or textNode.nodeType ~= "text" then return "" end
          
          local value = escapeHtml(textNode.value or "")
          
          if textNode.marks then
            for _, mark in ipairs(textNode.marks) do
              if mark.type == "bold" then
                value = "<strong>" .. value .. "</strong>"
              elseif mark.type == "italic" then
                value = "<em>" .. value .. "</em>"
              elseif mark.type == "code" then
                value = "<code>" .. value .. "</code>"
              elseif mark.type == "underline" then
                value = "<u>" .. value .. "</u>"
              end
            end
          end
          
          return value
        end
        
        local function renderRichText(richTextObj, includes)
          if not richTextObj or not richTextObj.content then
            return ""
          end
          
          -- Helper function to resolve entry references from includes
          local function resolveEntry(entryId)
            if not includes or not includes.Entry then return nil end
            for _, entry in ipairs(includes.Entry) do
              if entry.sys and entry.sys.id == entryId then
                return entry
              end
            end
            return nil
          end
          
          local html = ""
          for _, node in ipairs(richTextObj.content) do
            
            -- Handle embedded assets (images)
            if node.nodeType == "embedded-asset-block" then
              if node.data and node.data.target and node.data.target.fields then
                local asset = node.data.target.fields
                local url = asset.file and asset.file.url or ""
                local title = asset.title or ""
                local description = asset.description or title
                
                -- Ensure HTTPS URLs
                if url:sub(1, 2) == "//" then
                  url = "https:" .. url
                end
                
                html = html .. string.format('<img src="%s" alt="%s" title="%s" class="embedded-asset" loading="lazy" />\n', 
                                           escapeHtml(url), escapeHtml(description), escapeHtml(title))
              end
              
            -- Handle embedded entries (code blocks, etc.)
            elseif node.nodeType == "embedded-entry-block" then
              if node.data and node.data.target and node.data.target.sys then
                local entryId = node.data.target.sys.id
                local resolvedEntry = resolveEntry(entryId)
                
                if resolvedEntry and resolvedEntry.fields then
                  local contentType = resolvedEntry.sys and resolvedEntry.sys.contentType and resolvedEntry.sys.contentType.sys and resolvedEntry.sys.contentType.sys.id
                  
                  if (contentType == "codeBlock" or contentType == "codeSample") then
                    local code = escapeHtml(resolvedEntry.fields.code or "")
                    local lang = resolvedEntry.fields.lang or resolvedEntry.fields.language or "text"
                    local filename = resolvedEntry.fields.filename and (" data-filename=\"" .. escapeHtml(resolvedEntry.fields.filename) .. "\"") or ""
                    local title = resolvedEntry.fields.title and ("\n<!-- " .. escapeHtml(resolvedEntry.fields.title) .. " -->\n") or ""
                    
                    html = html .. title .. string.format('<pre class="code-block"><code class="language-%s"%s>%s</code></pre>\n', 
                                                         escapeHtml(lang), filename, code)
                  end
                end
              end
              
            -- Handle paragraphs with inline content
            elseif node.nodeType == "paragraph" and node.content then
              html = html .. "<p>"
              for _, inline in ipairs(node.content) do
                if inline.nodeType == "text" then
                  html = html .. renderTextWithMarks(inline)
                elseif inline.nodeType == "hyperlink" then
                  local linkText = ""
                  if inline.content then
                    for _, linkContent in ipairs(inline.content) do
                      linkText = linkText .. renderTextWithMarks(linkContent)
                    end
                  end
                  local uri = inline.data and inline.data.uri or "#"
                  html = html .. string.format('<a href="%s" target="_blank" rel="noopener noreferrer">%s</a>', 
                                              escapeHtml(uri), linkText)
                elseif inline.nodeType == "entry-hyperlink" then
                  local linkText = ""
                  if inline.content then
                    for _, linkContent in ipairs(inline.content) do
                      linkText = linkText .. renderTextWithMarks(linkContent)
                    end
                  end
                  local target = inline.data and inline.data.target
                  local href = generateEntryUrl(target)
                  local title = target and target.fields and target.fields.title or ""
                  
                  html = html .. string.format('<a href="%s" title="%s">%s</a>', 
                                              escapeHtml(href), escapeHtml(title), linkText)
                elseif inline.nodeType == "asset-hyperlink" then
                  local linkText = ""
                  if inline.content then
                    for _, linkContent in ipairs(inline.content) do
                      linkText = linkText .. renderTextWithMarks(linkContent)
                    end
                  end
                  local target = inline.data and inline.data.target
                  local url = target and target.fields and target.fields.file and target.fields.file.url or "#"
                  
                  if url:sub(1, 2) == "//" then
                    url = "https:" .. url
                  end
                  
                  html = html .. string.format('<a href="%s" download>%s</a>', escapeHtml(url), linkText)
                end
              end
              html = html .. "</p>\n"
              
            -- Handle headings
            elseif node.nodeType == "heading-1" and node.content then
              html = html .. "<h1>"
              for _, textNode in ipairs(node.content) do
                html = html .. renderTextWithMarks(textNode)
              end
              html = html .. "</h1>\n"
            elseif node.nodeType == "heading-2" and node.content then
              html = html .. "<h2>"
              for _, textNode in ipairs(node.content) do
                html = html .. renderTextWithMarks(textNode)
              end
              html = html .. "</h2>\n"
            elseif node.nodeType == "heading-3" and node.content then
              html = html .. "<h3>"
              for _, textNode in ipairs(node.content) do
                html = html .. renderTextWithMarks(textNode)
              end
              html = html .. "</h3>\n"
            elseif node.nodeType == "heading-4" and node.content then
              html = html .. "<h4>"
              for _, textNode in ipairs(node.content) do
                html = html .. renderTextWithMarks(textNode)
              end
              html = html .. "</h4>\n"
            elseif node.nodeType == "heading-5" and node.content then
              html = html .. "<h5>"
              for _, textNode in ipairs(node.content) do
                html = html .. renderTextWithMarks(textNode)
              end
              html = html .. "</h5>\n"
            elseif node.nodeType == "heading-6" and node.content then
              html = html .. "<h6>"
              for _, textNode in ipairs(node.content) do
                html = html .. renderTextWithMarks(textNode)
              end
              html = html .. "</h6>\n"
              
            -- Handle lists
            elseif node.nodeType == "unordered-list" and node.content then
              html = html .. "<ul>\n"
              for _, listItem in ipairs(node.content) do
                if listItem.nodeType == "list-item" and listItem.content then
                  html = html .. "<li>"
                  for _, itemContent in ipairs(listItem.content) do
                    if itemContent.nodeType == "paragraph" and itemContent.content then
                      for _, textNode in ipairs(itemContent.content) do
                        html = html .. renderTextWithMarks(textNode)
                      end
                    else
                      -- Recursively handle nested content
                      html = html .. renderRichText(itemContent)
                    end
                  end
                  html = html .. "</li>\n"
                end
              end
              html = html .. "</ul>\n"
            elseif node.nodeType == "ordered-list" and node.content then
              html = html .. "<ol>\n"
              for _, listItem in ipairs(node.content) do
                if listItem.nodeType == "list-item" and listItem.content then
                  html = html .. "<li>"
                  for _, itemContent in ipairs(listItem.content) do
                    if itemContent.nodeType == "paragraph" and itemContent.content then
                      for _, textNode in ipairs(itemContent.content) do
                        html = html .. renderTextWithMarks(textNode)
                      end
                    else
                      html = html .. renderRichText(itemContent)
                    end
                  end
                  html = html .. "</li>\n"
                end
              end
              html = html .. "</ol>\n"
              
            -- Handle blockquotes
            elseif node.nodeType == "blockquote" and node.content then
              html = html .. "<blockquote>\n"
              for _, quoteContent in ipairs(node.content) do
                if quoteContent.nodeType == "paragraph" and quoteContent.content then
                  html = html .. "<p>"
                  for _, textNode in ipairs(quoteContent.content) do
                    html = html .. renderTextWithMarks(textNode)
                  end
                  html = html .. "</p>\n"
                else
                  html = html .. renderRichText(quoteContent)
                end
              end
              html = html .. "</blockquote>\n"
              
            -- Handle horizontal rule
            elseif node.nodeType == "hr" then
              html = html .. "<hr />\n"
              
            -- Handle table (basic support)
            elseif node.nodeType == "table" and node.content then
              html = html .. "<table>\n"
              for _, row in ipairs(node.content) do
                if row.nodeType == "table-row" and row.content then
                  html = html .. "<tr>\n"
                  for _, cell in ipairs(row.content) do
                    if cell.nodeType == "table-cell" or cell.nodeType == "table-header-cell" then
                      local tag = cell.nodeType == "table-header-cell" and "th" or "td"
                      html = html .. "<" .. tag .. ">"
                      if cell.content then
                        for _, cellContent in ipairs(cell.content) do
                          html = html .. renderRichText(cellContent)
                        end
                      end
                      html = html .. "</" .. tag .. ">\n"
                    end
                  end
                  html = html .. "</tr>\n"
                end
              end
              html = html .. "</table>\n"
            end
          end
          return html
        end
        
        return {
          title = fields.title or "Untitled",
          bodyHtml = renderRichText(fields.body, request.data.response.includes),
          slug = fields.slug or "",
          publishedDate = fields.publishedDate or entry.sys.createdAt,
          author = fields.author or "William Cotton",
          excerpt = fields.excerpt or "",
          tags = fields.tags or {},
          seoDescription = fields.seoDescription or fields.excerpt or "",
          contentType = entry.sys.contentType.sys.id,
          found = true
        }
      else
        return {
          found = false,
          message = "Article not found with slug: " .. slug
        }
      end
    else
      return {
        error = "Failed to fetch article from Contentful",
        slug = slug
      }
    end
  `
  |> mustache: `
    <html>
      <head>
        <title>{{#found}}{{title}} - William Cotton{{/found}}{{^found}}Article Not Found{{/found}}</title>
        {{#seoDescription}}<meta name="description" content="{{seoDescription}}">{{/seoDescription}}
        <meta name="author" content="{{author}}">
        <link rel="preload" href="https://williamcotton.com/LigaMenlo-Regular.woff" as="font" type="font/woff">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        {{>highlightJsScript}}
        <style>
          @font-face {
            font-family: 'LigaMenlo-Regular';
            src: url('https://williamcotton.com/LigaMenlo-Regular.woff') format('woff');
            font-display: swap;
          }
          body { font-family: Georgia, serif; max-width: 800px; margin: 0 auto; padding: 40px 20px; line-height: 1.6; }
          .article-header { margin-bottom: 40px; }
          .article-meta { color: #666; font-size: 14px; margin: 20px 0; }
          .article-content { font-size: 18px; }
          .article-content h1, .article-content h2, .article-content h3, .article-content h4, .article-content h5, .article-content h6 { 
            margin-top: 40px; margin-bottom: 20px; color: #333; line-height: 1.3; 
          }
          .article-content h1 { font-size: 2.2em; }
          .article-content h2 { font-size: 1.8em; }
          .article-content h3 { font-size: 1.4em; }
          .article-content h4 { font-size: 1.2em; }
          .article-content h5 { font-size: 1.1em; }
          .article-content h6 { font-size: 1em; font-weight: bold; }
          .article-content blockquote { 
            border-left: 4px solid #007acc; padding-left: 20px; margin: 30px 0; 
            font-style: italic; background: #f8f9fa; padding: 20px; border-radius: 4px;
          }
          .article-content code { 
            background: #f5f5f5; padding: 2px 6px; border-radius: 3px; 
            font-family: 'LigaMenlo-Regular', 'Monaco', 'Menlo', 'Ubuntu Mono', monospace; font-size: 0.9em; 
          }
          .article-content pre { 
            background: #f8f9fa; padding: 20px; border-radius: 6px; 
            overflow-x: auto; margin: 30px 0; border: 1px solid #e9ecef;
          }
          .article-content pre code { 
            background: none; padding: 0; border-radius: 0; display: block;
            font-size: 14px; line-height: 1.5;
            font-family: 'LigaMenlo-Regular', 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
          }
          .article-content pre.code-block {
            position: relative;
          }
          .article-content pre.code-block::before {
            content: attr(data-filename);
            position: absolute;
            top: -10px;
            right: 10px;
            background: #007acc;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-family: sans-serif;
          }
          .article-content .embedded-asset {
            max-width: 100%; height: auto; margin: 30px 0;
            border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);
          }
          .article-content ul, .article-content ol {
            margin: 20px 0; padding-left: 30px;
          }
          .article-content li {
            margin: 8px 0;
          }
          .article-content table {
            width: 100%; border-collapse: collapse; margin: 30px 0;
            border: 1px solid #e9ecef;
          }
          .article-content th, .article-content td {
            padding: 12px; text-align: left; border-bottom: 1px solid #e9ecef;
          }
          .article-content th {
            background: #f8f9fa; font-weight: bold;
          }
          .article-content hr {
            border: none; height: 2px; background: #e9ecef;
            margin: 40px 0;
          }
          .article-content a {
            color: #007acc; text-decoration: none;
          }
          .article-content a:hover {
            text-decoration: underline;
          }
          .article-content strong {
            font-weight: bold;
          }
          .article-content em {
            font-style: italic;
          }
          .article-content u {
            text-decoration: underline;
          }
          .tags { margin-top: 30px; }
          .tag { background: #f0f0f0; padding: 4px 8px; margin-right: 8px; border-radius: 3px; font-size: 12px; }
          .back-link { color: #007acc; text-decoration: none; }
          .back-link:hover { text-decoration: underline; }
          .error { color: red; background: #ffe6e6; padding: 20px; border: 1px solid red; }
          .not-found { text-align: center; padding: 60px 20px; }
        </style>
      </head>
      <body>
        {{#found}}
          <article>
            <header class="article-header">
              <h1>{{title}}</h1>
              <div class="article-meta">
                By {{author}} on {{publishedDate}}<br>
                {{#excerpt}}<em>{{excerpt}}</em>{{/excerpt}}
              </div>
            </header>
            
            <div class="article-content">
              {{{bodyHtml}}}
            </div>

            <div style="margin-top: 50px; padding-top: 20px; border-top: 1px solid #eee;">
              <a href="/contentful/articles" class="back-link">Back to all articles</a>
            </div>
          </article>
        {{/found}}
        {{^found}}
          <div class="not-found">
            <h1>Article Not Found</h1>
            <p>{{message}}</p>
            <a href="/contentful/articles" class="back-link">Back to all articles</a>
          </div>
        {{/found}}
        {{#error}}
          <div class="error">
            <h2>Error</h2>
            <p>{{error}}</p>
          </div>
        {{/error}}
      </body>
    </html>
  `

## Page by slug (matching F# page function)
GET /contentful/page/:slug
  |> lua: `
    local spaceId = getEnv("CONTENTFUL_SPACE")
    local token = getEnv("CONTENTFUL_ACCESS_TOKEN")
    local slug = request.params.slug
    
    if not spaceId or not token then
      return {
        errors = {{
          type = "configError", 
          message = "Missing Contentful configuration"
        }}
      }
    end
    
    return {
      fetchUrl = "https://cdn.contentful.com/spaces/" .. spaceId .. "/entries?content_type=page&fields.slug[in]=" .. slug,
      fetchHeaders = {
        ["Authorization"] = "Bearer " .. token
      }
    }
  `
  |> fetch: `placeholder`
  |> lua: `
    if request.data and request.data.response and request.data.response.items then
      local items = request.data.response.items
      if #items > 0 then
        local entry = items[1]
        local fields = entry.fields or {}
        
        -- Basic rich text processing for pages
        local function renderRichText(richTextObj, includes)
          if not richTextObj or not richTextObj.content then
            return ""
          end
          
          local html = ""
          for _, node in ipairs(richTextObj.content) do
            if node.nodeType == "paragraph" and node.content then
              html = html .. "<p>"
              for _, textNode in ipairs(node.content) do
                if textNode.nodeType == "text" then
                  html = html .. (textNode.value or "")
                end
              end
              html = html .. "</p>\n"
            elseif node.nodeType == "heading-1" and node.content then
              html = html .. "<h1>"
              for _, textNode in ipairs(node.content) do
                if textNode.nodeType == "text" then
                  html = html .. (textNode.value or "")
                end
              end
              html = html .. "</h1>\n"
            elseif node.nodeType == "heading-2" and node.content then
              html = html .. "<h2>"
              for _, textNode in ipairs(node.content) do
                if textNode.nodeType == "text" then
                  html = html .. (textNode.value or "")
                end
              end
              html = html .. "</h2>\n"
            end
          end
          return html
        end
        
        return {
          title = fields.title or "Untitled",
          bodyHtml = renderRichText(fields.body, request.data.response.includes),
          slug = fields.slug or "",
          seoDescription = fields.seoDescription or "",
          contentType = entry.sys.contentType.sys.id,
          found = true
        }
      else
        return {
          found = false,
          message = "Page not found with slug: " .. slug
        }
      end
    else
      return {
        error = "Failed to fetch page from Contentful",
        slug = slug
      }
    end
  `
  |> mustache: `
    <html>
      <head>
        <title>{{#found}}{{title}} - William Cotton{{/found}}{{^found}}Page Not Found{{/found}}</title>
        {{#seoDescription}}<meta name="description" content="{{seoDescription}}">{{/seoDescription}}
        <style>
          body { font-family: Georgia, serif; max-width: 800px; margin: 0 auto; padding: 40px 20px; line-height: 1.6; }
          .page-content { font-size: 18px; }
          .error { color: red; background: #ffe6e6; padding: 20px; border: 1px solid red; }
          .not-found { text-align: center; padding: 60px 20px; }
          .back-link { color: #007acc; text-decoration: none; }
          .back-link:hover { text-decoration: underline; }
        </style>
      </head>
      <body>
        {{#found}}
          <div class="page-content">
            <h1>{{title}}</h1>
            {{{bodyHtml}}}
          </div>
        {{/found}}
        {{^found}}
          <div class="not-found">
            <h1>Page Not Found</h1>
            <p>{{message}}</p>
            <a href="/" class="back-link">← Back to home</a>
          </div>
        {{/found}}
        {{#error}}
          <div class="error">
            <h2>Error</h2>
            <p>{{error}}</p>
          </div>
        {{/error}}
      </body>
    </html>
  `

## Test route for Contentful configuration
GET /contentful/config
  |> lua: `
    local spaceId = getEnv("CONTENTFUL_SPACE")
    local token = getEnv("CONTENTFUL_ACCESS_TOKEN")
    
    return {
      hasSpaceId = (spaceId ~= nil),
      hasToken = (token ~= nil),
      spaceId = spaceId,
      message = "Contentful configuration status"
    }
  `

## Debug route to see raw Contentful response
GET /contentful/debug/:slug
  |> lua: `
    local spaceId = getEnv("CONTENTFUL_SPACE")
    local token = getEnv("CONTENTFUL_ACCESS_TOKEN")
    local slug = request.params.slug
    
    if not spaceId or not token then
      return {
        errors = {{
          type = "configError", 
          message = "Missing Contentful configuration"
        }}
      }
    end
    
    return {
      fetchUrl = "https://cdn.contentful.com/spaces/" .. spaceId .. "/entries?content_type=blogPost&fields.slug[in]=" .. slug,
      fetchHeaders = {
        ["Authorization"] = "Bearer " .. token
      }
    }
  `
  |> fetch: `placeholder`
  |> lua: `
    return {
      rawResponse = request.data.response,
      message = "Raw Contentful API response for debugging"
    }
  `
  |> mustache: `
    <html>
      <head><title>Debug: {{message}}</title></head>
      <body>
        <h1>{{message}}</h1>
        <pre style="background: #f5f5f5; padding: 20px; overflow-x: auto; white-space: pre-wrap;">{{rawResponse}}</pre>
      </body>
    </html>
  `